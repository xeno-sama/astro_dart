{
    "sourceFile": "bin/vsop/src/func.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 111,
            "patches": [
                {
                    "date": 1642125034994,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1642133079925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,9 @@\n import 'dart:math';\n+import 'classes.dart';\n \n+const ASEC2RAD = 4.848136811095359935899141e-6;\n+\n double radians(double rad) => rad * pi / 180;\n double degrees(double grad) => grad / pi * 180;\n \n //Приведение к 360 градусов\n@@ -53,102 +56,103 @@\n   var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n   return map2;\n }\n \n-// def precession_rot(time, direction):\n-//     eps0 = 84381.406\n-//     t = time.tt / 36525\n+RotationMatrix precession_rot(time, direction){\n+    double eps0 = 84381.406;\n+    double t = time.tt / 36525;\n \n-//     psia = (((((- 0.0000000951 * t\n-//                 + 0.000132851) * t\n-//                - 0.00114045) * t\n-//               - 1.0790069) * t\n-//              + 5038.481507) * t)\n+    var psia = (((((- 0.0000000951 * t\n+                + 0.000132851) * t\n+               - 0.00114045) * t\n+              - 1.0790069) * t\n+             + 5038.481507) * t);\n \n-//     omegaa = (((((+ 0.0000003337 * t\n-//                  - 0.000000467) * t\n-//                  - 0.00772503) * t\n-//                 + 0.0512623) * t\n-//                - 0.025754) * t + eps0)\n+    var omegaa = (((((+ 0.0000003337 * t\n+                 - 0.000000467) * t\n+                 - 0.00772503) * t\n+                + 0.0512623) * t\n+               - 0.025754) * t + eps0);\n \n-//     chia = (((((- 0.0000000560 * t\n-//                 + 0.000170663) * t\n-//                - 0.00121197) * t\n-//               - 2.3814292) * t\n-//              + 10.556403) * t)\n+    var chia = (((((- 0.0000000560 * t\n+                + 0.000170663) * t\n+               - 0.00121197) * t\n+              - 2.3814292) * t\n+             + 10.556403) * t);\n \n-//     eps0 *= ASEC2RAD\n-//     psia *= ASEC2RAD\n-//     omegaa *= ASEC2RAD\n-//     chia *= ASEC2RAD\n+    eps0 *= ASEC2RAD;\n+    psia *= ASEC2RAD;\n+    omegaa *= ASEC2RAD;\n+    chia *= ASEC2RAD;\n \n-//     sa = sin(eps0)\n-//     ca = cos(eps0)\n-//     sb = sin(-psia)\n-//     cb = cos(-psia)\n-//     sc = sin(-omegaa)\n-//     cc = cos(-omegaa)\n-//     sd = sin(chia)\n-//     cd = cos(chia)\n+    sa = sin(eps0);\n+    ca = cos(eps0);\n+    sb = sin(-psia);\n+    cb = cos(-psia);\n+    sc = sin(-omegaa);\n+    cc = cos(-omegaa);\n+    sd = sin(chia);\n+    cd = cos(chia);\n \n-//     xx = cd * cb - sb * sd * cc\n-//     yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc\n-//     zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc\n-//     xy = -sd * cb - sb * cd * cc\n-//     yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc\n-//     zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc\n-//     xz = sb * sc\n-//     yz = -sc * cb * ca - sa * cc\n-//     zz = -sc * cb * sa + cc * ca\n-//     if direction == PrecessDir.Into2000:\n-//         # Perform rotation from other epoch to J2000.0.\n-//         return RotationMatrix([\n-//             [xx, yx, zx],\n-//             [xy, yy, zy],\n-//             [xz, yz, zz]\n-//         ])\n+    xx = cd * cb - sb * sd * cc;\n+    yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc;\n+    zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc;\n+    xy = -sd * cb - sb * cd * cc;\n+    yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc;\n+    zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc;\n+    xz = sb * sc;\n+    yz = -sc * cb * ca - sa * cc;\n+    zz = -sc * cb * sa + cc * ca;\n+    if direction == PrecessDir.Into2000:\n+        // Perform rotation from other epoch to J2000.0.\n+        return RotationMatrix([\n+            [xx, yx, zx],\n+            [xy, yy, zy],\n+            [xz, yz, zz]\n+        ]);\n \n-//     if direction == PrecessDir.From2000:\n-//         # Perform rotation from J2000.0 to other epoch.\n-//         return RotationMatrix([\n-//             [xx, xy, xz],\n-//             [yx, yy, yz],\n-//             [zx, zy, zz]\n-//         ])\n+    if direction == PrecessDir.From2000:\n+        //Perform rotation from J2000.0 to other epoch.\n+        return RotationMatrix([\n+            [xx, xy, xz],\n+            [yx, yy, yz],\n+            [zx, zy, zz]\n+        ]);}\n \n //     raise Error('Inalid precession direction')\n \n-// def mean_obliq(tt):\n-//     t = tt / 36525\n-//     asec = (\n-//         ((((- 0.0000000434 * t\n-//             - 0.000000576) * t\n-//            + 0.00200340) * t\n-//           - 0.0001831) * t\n-//          - 46.836769) * t + 84381.406\n-//     )\n-//     return asec / 3600.0\n+double mean_obliq(tt) {\n+  double t = tt / 36525;\n+  double asec =\n+      (((((-0.0000000434 * t - 0.000000576) * t + 0.00200340) * t - 0.0001831) *\n+                      t -\n+                  46.836769) *\n+              t +\n+          84381.406);\n+  return asec / 3600.0;\n+}\n \n-// def ecl2equ_vec(time, ecl):\n-//     obl = radians(mean_obliq(time.tt))\n-//     cos_obl = cos(obl)\n-//     sin_obl = sin(obl)\n-//     return [\n-//         ecl[0],\n-//         ecl[1]*cos_obl - ecl[2]*sin_obl,\n-//         ecl[1]*sin_obl + ecl[2]*cos_obl\n-//     ]\n+List ecl2equ_vec(time, ecl) {\n+  double obl = radians(mean_obliq(time.tt));\n+  double cos_obl = cos(obl);\n+  double sin_obl = sin(obl);\n+  return [\n+    ecl[0],\n+    ecl[1] * cos_obl - ecl[2] * sin_obl,\n+    ecl[1] * sin_obl + ecl[2] * cos_obl\n+  ];\n+}\n \n-// def rotate(rot, vec):\n-//     return [\n-//         rot.rot[0][0]*vec[0] + rot.rot[1][0]*vec[1] + rot.rot[2][0]*vec[2],\n-//         rot.rot[0][1]*vec[0] + rot.rot[1][1]*vec[1] + rot.rot[2][1]*vec[2],\n-//         rot.rot[0][2]*vec[0] + rot.rot[1][2]*vec[1] + rot.rot[2][2]*vec[2]\n-//     ]\n+List rotate(rot, vec) => [\n+      rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n+      rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n+      rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n+    ];\n \n-// def precession(pos, time, direction):\n-//     r = precession_rot(time, direction)\n-//     return rotate(r, pos)\n+List precession(pos, time, direction) {\n+  var r = precession_rot(time, direction);\n+  return rotate(r, pos);\n+}\n \n // # -------------------------\n // # 1. Парсинг входной даты\n // # -------------------------\n"
                },
                {
                    "date": 1642133398813,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,21 +60,21 @@\n RotationMatrix precession_rot(time, direction){\n     double eps0 = 84381.406;\n     double t = time.tt / 36525;\n \n-    var psia = (((((- 0.0000000951 * t\n+    double psia = (((((- 0.0000000951 * t\n                 + 0.000132851) * t\n                - 0.00114045) * t\n               - 1.0790069) * t\n              + 5038.481507) * t);\n \n-    var omegaa = (((((+ 0.0000003337 * t\n+    double omegaa = (((((+ 0.0000003337 * t\n                  - 0.000000467) * t\n                  - 0.00772503) * t\n                 + 0.0512623) * t\n                - 0.025754) * t + eps0);\n \n-    var chia = (((((- 0.0000000560 * t\n+    double chia = (((((- 0.0000000560 * t\n                 + 0.000170663) * t\n                - 0.00121197) * t\n               - 2.3814292) * t\n              + 10.556403) * t);\n@@ -83,41 +83,43 @@\n     psia *= ASEC2RAD;\n     omegaa *= ASEC2RAD;\n     chia *= ASEC2RAD;\n \n-    sa = sin(eps0);\n-    ca = cos(eps0);\n-    sb = sin(-psia);\n-    cb = cos(-psia);\n-    sc = sin(-omegaa);\n-    cc = cos(-omegaa);\n-    sd = sin(chia);\n-    cd = cos(chia);\n+    double sa = sin(eps0);\n+    double ca = cos(eps0);\n+    double sb = sin(-psia);\n+    double cb = cos(-psia);\n+    double sc = sin(-omegaa);\n+    double cc = cos(-omegaa);\n+    double sd = sin(chia);\n+    double cd = cos(chia);\n \n-    xx = cd * cb - sb * sd * cc;\n-    yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc;\n-    zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc;\n-    xy = -sd * cb - sb * cd * cc;\n-    yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc;\n-    zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc;\n-    xz = sb * sc;\n-    yz = -sc * cb * ca - sa * cc;\n-    zz = -sc * cb * sa + cc * ca;\n-    if direction == PrecessDir.Into2000:\n-        // Perform rotation from other epoch to J2000.0.\n-        return RotationMatrix([\n+    double xx = cd * cb - sb * sd * cc;\n+    double yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc;\n+    double zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc;\n+    double xy = -sd * cb - sb * cd * cc;\n+    double yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc;\n+    double zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc;\n+    double xz = sb * sc;\n+    double yz = -sc * cb * ca - sa * cc;\n+    double zz = -sc * cb * sa + cc * ca;\n+    \n+    if (direction == PrecessDir.Into2000) {\n+      return RotationMatrix([\n             [xx, yx, zx],\n             [xy, yy, zy],\n             [xz, yz, zz]\n         ]);\n+    } \n \n-    if direction == PrecessDir.From2000:\n+    if (direction == PrecessDir.From2000)\n         //Perform rotation from J2000.0 to other epoch.\n-        return RotationMatrix([\n+        {return RotationMatrix([\n             [xx, xy, xz],\n             [yx, yy, yz],\n             [zx, zy, zz]\n-        ]);}\n+        ]);\n+        }\n \n //     raise Error('Inalid precession direction')\n \n double mean_obliq(tt) {\n"
                },
                {
                    "date": 1642133589245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,71 +56,74 @@\n   var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n   return map2;\n }\n \n-RotationMatrix precession_rot(time, direction){\n-    double eps0 = 84381.406;\n-    double t = time.tt / 36525;\n+RotationMatrix? precession_rot(time, direction) {\n+  double eps0 = 84381.406;\n+  double t = time.tt / 36525;\n \n-    double psia = (((((- 0.0000000951 * t\n-                + 0.000132851) * t\n-               - 0.00114045) * t\n-              - 1.0790069) * t\n-             + 5038.481507) * t);\n+  double psia =\n+      (((((-0.0000000951 * t + 0.000132851) * t - 0.00114045) * t - 1.0790069) *\n+                  t +\n+              5038.481507) *\n+          t);\n \n-    double omegaa = (((((+ 0.0000003337 * t\n-                 - 0.000000467) * t\n-                 - 0.00772503) * t\n-                + 0.0512623) * t\n-               - 0.025754) * t + eps0);\n+  double omegaa =\n+      (((((0.0000003337 * t - 0.000000467) * t - 0.00772503) * t + 0.0512623) *\n+                      t -\n+                  0.025754) *\n+              t +\n+          eps0);\n \n-    double chia = (((((- 0.0000000560 * t\n-                + 0.000170663) * t\n-               - 0.00121197) * t\n-              - 2.3814292) * t\n-             + 10.556403) * t);\n+  double chia =\n+      (((((-0.0000000560 * t + 0.000170663) * t - 0.00121197) * t - 2.3814292) *\n+                  t +\n+              10.556403) *\n+          t);\n \n-    eps0 *= ASEC2RAD;\n-    psia *= ASEC2RAD;\n-    omegaa *= ASEC2RAD;\n-    chia *= ASEC2RAD;\n+  eps0 *= ASEC2RAD;\n+  psia *= ASEC2RAD;\n+  omegaa *= ASEC2RAD;\n+  chia *= ASEC2RAD;\n \n-    double sa = sin(eps0);\n-    double ca = cos(eps0);\n-    double sb = sin(-psia);\n-    double cb = cos(-psia);\n-    double sc = sin(-omegaa);\n-    double cc = cos(-omegaa);\n-    double sd = sin(chia);\n-    double cd = cos(chia);\n+  double sa = sin(eps0);\n+  double ca = cos(eps0);\n+  double sb = sin(-psia);\n+  double cb = cos(-psia);\n+  double sc = sin(-omegaa);\n+  double cc = cos(-omegaa);\n+  double sd = sin(chia);\n+  double cd = cos(chia);\n \n-    double xx = cd * cb - sb * sd * cc;\n-    double yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc;\n-    double zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc;\n-    double xy = -sd * cb - sb * cd * cc;\n-    double yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc;\n-    double zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc;\n-    double xz = sb * sc;\n-    double yz = -sc * cb * ca - sa * cc;\n-    double zz = -sc * cb * sa + cc * ca;\n-    \n-    if (direction == PrecessDir.Into2000) {\n-      return RotationMatrix([\n-            [xx, yx, zx],\n-            [xy, yy, zy],\n-            [xz, yz, zz]\n-        ]);\n-    } \n+  double xx = cd * cb - sb * sd * cc;\n+  double yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc;\n+  double zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc;\n+  double xy = -sd * cb - sb * cd * cc;\n+  double yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc;\n+  double zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc;\n+  double xz = sb * sc;\n+  double yz = -sc * cb * ca - sa * cc;\n+  double zz = -sc * cb * sa + cc * ca;\n \n-    if (direction == PrecessDir.From2000)\n-        //Perform rotation from J2000.0 to other epoch.\n-        {return RotationMatrix([\n-            [xx, xy, xz],\n-            [yx, yy, yz],\n-            [zx, zy, zz]\n-        ]);\n-        }\n+  if (direction == PrecessDir.Into2000) {\n+    return RotationMatrix([\n+      [xx, yx, zx],\n+      [xy, yy, zy],\n+      [xz, yz, zz]\n+    ]);\n+  }\n \n+  if (direction == PrecessDir.From2000)\n+  //Perform rotation from J2000.0 to other epoch.\n+  {\n+    return RotationMatrix([\n+      [xx, xy, xz],\n+      [yx, yy, yz],\n+      [zx, zy, zz]\n+    ]);\n+  }\n+}\n+\n //     raise Error('Inalid precession direction')\n \n double mean_obliq(tt) {\n   double t = tt / 36525;\n@@ -153,22 +156,4 @@\n List precession(pos, time, direction) {\n   var r = precession_rot(time, direction);\n   return rotate(r, pos);\n }\n-\n-// # -------------------------\n-// # 1. Парсинг входной даты\n-// # -------------------------\n-\n-// # def ParseArgs(args):\n-// #     if len(args) not in [3, 4]:\n-// #         print(\n-// #             'USAGE: {} latitude longitude [yyyy-mm-ddThh:mm:ssZ]'.format(args[0]))\n-// #         sys.exit(1)\n-// #     latitude = float(args[1])\n-// #     longitude = float(args[2])\n-// #     if len(args) == 4:\n-// #         time = Time.Parse(args[3])\n-// #     else:\n-// #         time = Time.Now()\n-// #     observer = Observer(latitude, longitude)\n-// #     return (observer, time)\n"
                },
                {
                    "date": 1642133599871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,7 @@\n+// ------\n+// Ready\n+// ------\n import 'dart:math';\n import 'classes.dart';\n \n const ASEC2RAD = 4.848136811095359935899141e-6;\n"
                },
                {
                    "date": 1642429163282,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,4 +159,8 @@\n List precession(pos, time, direction) {\n   var r = precession_rot(time, direction);\n   return rotate(r, pos);\n }\n+\n+double fmod(double x, double y) {\n+  return x - (x / y) * y.truncate();\n+}\n"
                },
                {
                    "date": 1642429256347,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,6 +161,6 @@\n   return rotate(r, pos);\n }\n \n double fmod(double x, double y) {\n-  return x - (x / y) * y.truncate();\n+  return x - ((x / y) * y).truncate();\n }\n"
                },
                {
                    "date": 1642429293648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,6 +161,6 @@\n   return rotate(r, pos);\n }\n \n double fmod(double x, double y) {\n-  return x - ((x / y) * y).truncate();\n+  return x - (x / y).truncate() * y;\n }\n"
                },
                {
                    "date": 1642485471111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,9 +139,9 @@\n   return asec / 3600.0;\n }\n \n List ecl2equ_vec(time, ecl) {\n-  double obl = radians(mean_obliq(time.tt));\n+  double obl = radians(mean_obliq(time));\n   double cos_obl = cos(obl);\n   double sin_obl = sin(obl);\n   return [\n     ecl[0],\n"
                },
                {
                    "date": 1642485508528,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n }\n \n RotationMatrix? precession_rot(time, direction) {\n   double eps0 = 84381.406;\n-  double t = time.tt / 36525;\n+  double t = time / 36525;\n \n   double psia =\n       (((((-0.0000000951 * t + 0.000132851) * t - 0.00114045) * t - 1.0790069) *\n                   t +\n"
                },
                {
                    "date": 1642567214497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,9 +128,9 @@\n \n //     raise Error('Inalid precession direction')\n \n double mean_obliq(tt) {\n-  double t = tt / 36525;\n+  double t = tt.tt / 36525;\n   double asec =\n       (((((-0.0000000434 * t - 0.000000576) * t + 0.00200340) * t - 0.0001831) *\n                       t -\n                   46.836769) *\n"
                },
                {
                    "date": 1642567234354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,10 +127,10 @@\n }\n \n //     raise Error('Inalid precession direction')\n \n-double mean_obliq(tt) {\n-  double t = tt.tt / 36525;\n+double mean_obliq(time) {\n+  double t = time.tt / 36525;\n   double asec =\n       (((((-0.0000000434 * t - 0.000000576) * t + 0.00200340) * t - 0.0001831) *\n                       t -\n                   46.836769) *\n"
                },
                {
                    "date": 1642567254204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n }\n \n RotationMatrix? precession_rot(time, direction) {\n   double eps0 = 84381.406;\n-  double t = time / 36525;\n+  double t = time.tt / 36525;\n \n   double psia =\n       (((((-0.0000000951 * t + 0.000132851) * t - 0.00114045) * t - 1.0790069) *\n                   t +\n"
                },
                {
                    "date": 1642567369743,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n }\n \n RotationMatrix? precession_rot(time, direction) {\n   double eps0 = 84381.406;\n-  double t = time.tt / 36525;\n+  double t = time / 36525;\n \n   double psia =\n       (((((-0.0000000951 * t + 0.000132851) * t - 0.00114045) * t - 1.0790069) *\n                   t +\n@@ -128,9 +128,9 @@\n \n //     raise Error('Inalid precession direction')\n \n double mean_obliq(time) {\n-  double t = time.tt / 36525;\n+  double t = time / 36525;\n   double asec =\n       (((((-0.0000000434 * t - 0.000000576) * t + 0.00200340) * t - 0.0001831) *\n                       t -\n                   46.836769) *\n"
                },
                {
                    "date": 1642569324307,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n // ------\n import 'dart:math';\n import 'classes.dart';\n \n-const ASEC2RAD = 4.848136811095359935899141e-6;\n+const asec2rad = 4.848136811095359935899141e-6;\n \n double radians(double rad) => rad * pi / 180;\n double degrees(double grad) => grad / pi * 180;\n \n@@ -59,9 +59,9 @@\n   var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n   return map2;\n }\n \n-RotationMatrix? precession_rot(time, direction) {\n+RotationMatrix? precessionRot(time, direction) {\n   double eps0 = 84381.406;\n   double t = time / 36525;\n \n   double psia =\n@@ -82,12 +82,12 @@\n                   t +\n               10.556403) *\n           t);\n \n-  eps0 *= ASEC2RAD;\n-  psia *= ASEC2RAD;\n-  omegaa *= ASEC2RAD;\n-  chia *= ASEC2RAD;\n+  eps0 *= asec2rad;\n+  psia *= asec2rad;\n+  omegaa *= asec2rad;\n+  chia *= asec2rad;\n \n   double sa = sin(eps0);\n   double ca = cos(eps0);\n   double sb = sin(-psia);\n@@ -156,9 +156,9 @@\n       rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n     ];\n \n List precession(pos, time, direction) {\n-  var r = precession_rot(time, direction);\n+  var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n \n double fmod(double x, double y) {\n"
                },
                {
                    "date": 1642578707712,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -106,17 +106,17 @@\n   double xz = sb * sc;\n   double yz = -sc * cb * ca - sa * cc;\n   double zz = -sc * cb * sa + cc * ca;\n \n-  if (direction == PrecessDir.Into2000) {\n+  if (direction == PrecessDir.into2000) {\n     return RotationMatrix([\n       [xx, yx, zx],\n       [xy, yy, zy],\n       [xz, yz, zz]\n     ]);\n   }\n \n-  if (direction == PrecessDir.From2000)\n+  if (direction == PrecessDir.from2000)\n   //Perform rotation from J2000.0 to other epoch.\n   {\n     return RotationMatrix([\n       [xx, xy, xz],\n"
                },
                {
                    "date": 1642608536158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,9 +127,9 @@\n }\n \n //     raise Error('Inalid precession direction')\n \n-double mean_obliq(time) {\n+double meanObliq(time) {\n   double t = time / 36525;\n   double asec =\n       (((((-0.0000000434 * t - 0.000000576) * t + 0.00200340) * t - 0.0001831) *\n                       t -\n@@ -138,16 +138,16 @@\n           84381.406);\n   return asec / 3600.0;\n }\n \n-List ecl2equ_vec(time, ecl) {\n-  double obl = radians(mean_obliq(time));\n-  double cos_obl = cos(obl);\n-  double sin_obl = sin(obl);\n+List ecl2equVec(time, ecl) {\n+  double obl = radians(meanObliq(time));\n+  double cosObl = cos(obl);\n+  double sinObl = sin(obl);\n   return [\n     ecl[0],\n-    ecl[1] * cos_obl - ecl[2] * sin_obl,\n-    ecl[1] * sin_obl + ecl[2] * cos_obl\n+    ecl[1] * cosObl - ecl[2] * sinObl,\n+    ecl[1] * sinObl + ecl[2] * cosObl\n   ];\n }\n \n List rotate(rot, vec) => [\n"
                },
                {
                    "date": 1642608657710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,9 @@\n   }\n   return rv;\n }\n \n-double time_24(double t0) {\n+double time24(double t0) {\n   var t = t0 - (t0 / 24.0).truncate() * 24.0;\n   if (t < 0.0) {\n     t += 24.0;\n   }\n@@ -48,9 +48,9 @@\n }\n \n double localSidTime(int hour, int minute, L, lon) {\n   double ut = hour + (minute / 60);\n-  double gmst0 = time_24(L / 15 + 12); // L солнечная долгота\n+  double gmst0 = time24(L / 15 + 12); // L солнечная долгота\n   double sidTime = gmst0 + ut + lon / 15;\n   double sidTimeDeg = sidTime * 15; //Звездное время в градусах\n   return sidTimeDeg;\n }\n"
                },
                {
                    "date": 1642608669945,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n double radians(double rad) => rad * pi / 180;\n double degrees(double grad) => grad / pi * 180;\n \n //Приведение к 360 градусов\n-double deg_360(double x) {\n+double deg360(double x) {\n   var rv = x - (x / 360.0).truncate() * 360.0;\n   if (rv < 0.0) {\n     rv += 360.0;\n   }\n"
                },
                {
                    "date": 1642863205515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -33,9 +33,13 @@\n   var sRA = ((ra / 15 - hRA) * 60 % 1 * 60).toInt();\n   return [hRA, mRA, sRA];\n }\n \n-double numDate(int y, int m, int D, int hour, int minute) {\n+double numDate(dat) {\n+  int y = dat.year;\n+  int m = dat.month;\n+  int hour = dat.hour;\n+  int minute = dat.minute;\n   int _d = (367 * y -\n           7 * (y + ((m + 9) / 12)).toInt() ~/ 4 -\n           3 * ((y + ((m - 9) / 7)).toInt() / 100 + 1) / 4 +\n           275 * m ~/ 9 +\n"
                },
                {
                    "date": 1642863259547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,8 +36,9 @@\n \n double numDate(dat) {\n   int y = dat.year;\n   int m = dat.month;\n+  int D = dat.day;\n   int hour = dat.hour;\n   int minute = dat.minute;\n   int _d = (367 * y -\n           7 * (y + ((m + 9) / 12)).toInt() ~/ 4 -\n"
                },
                {
                    "date": 1642918643446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,8 +7,9 @@\n const asec2rad = 4.848136811095359935899141e-6;\n \n double radians(double rad) => rad * pi / 180;\n double degrees(double grad) => grad / pi * 180;\n+double fmod(double x, double y) => x - (x / y).truncate() * y;\n \n //Приведение к 360 градусов\n double deg360(double x) {\n   var rv = x - (x / 360.0).truncate() * 360.0;\n@@ -164,8 +165,4 @@\n List precession(pos, time, direction) {\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n-\n-double fmod(double x, double y) {\n-  return x - (x / y).truncate() * y;\n-}\n"
                },
                {
                    "date": 1642918727224,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,12 +60,12 @@\n   double sidTimeDeg = sidTime * 15; //Звездное время в градусах\n   return sidTimeDeg;\n }\n \n-Map<int, String> test(double x) {\n-  var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n-  return map2;\n-}\n+// Map<int, String> test(double x) {\n+//   var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n+//   return map2;\n+// }\n \n RotationMatrix? precessionRot(time, direction) {\n   double eps0 = 84381.406;\n   double t = time / 36525;\n"
                },
                {
                    "date": 1642933678418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,4 +165,136 @@\n List precession(pos, time, direction) {\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n+\n+\n+// def vector2radec(pos, time):\n+//     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n+//     dist = sqrt(xyproj + pos[2]*pos[2])\n+//     if xyproj == 0.0:\n+//         # if pos[2] == 0.0:\n+//         #     # Indeterminate coordinates: pos vector has zero length.\n+//         #     raise BadVectorError()\n+//         ra = 0.0\n+//         if pos[2] < 0.0:\n+//             dec = -90.0\n+//         else:\n+//             dec = +90.0\n+//     else:\n+//         ra = RAD2HOUR * atan2(pos[1], pos[0])\n+//         if ra < 0:\n+//             ra += 24\n+//         dec = degrees(atan2(pos[2], sqrt(xyproj)))\n+//     vec = Vector(pos[0], pos[1], pos[2], time)\n+//     return vec#Equatorial(ra, dec, dist, vec)\n+\n+\n+// def terra_posvel(observer, st):\n+//     df2 = EARTH_FLATTENING ** 2\n+//     phi = radians(observer.latitude)\n+//     sinphi = sin(phi)\n+//     cosphi = cos(phi)\n+//     c = 1.0 / sqrt(cosphi*cosphi + df2*sinphi*sinphi)\n+//     s = df2 * c\n+//     ht_km = observer.height / 1000.0\n+//     ach = EARTH_EQUATORIAL_RADIUS_KM*c + ht_km\n+//     ash = EARTH_EQUATORIAL_RADIUS_KM*s + ht_km\n+//     stlocl = radians(15.0*st + observer.longitude)\n+//     sinst = sin(stlocl)\n+//     cosst = cos(stlocl)\n+//     return [\n+//         ach * cosphi * cosst / KM_PER_AU,\n+//         ach * cosphi * sinst / KM_PER_AU,\n+//         ash * sinphi / KM_PER_AU,\n+//         -ANGVEL * ach * cosphi * sinst * 86400 / KM_PER_AU,\n+//         ANGVEL * ach * cosphi * cosst * 86400 / KM_PER_AU,\n+//         0.0\n+//     ]\n+// def sidereal_time(time):\n+//     t = time.tt / 36525.0\n+//     # eqeq = 15.0 * time._etilt().ee    # Replace with eqeq=0 to get GMST instead of GAST (if we ever need it)\n+//     eqeq = 0\n+//     theta = era(time)\n+//     st = (eqeq + 0.014506 +\n+//         (((( -    0.0000000368   * t\n+//             -    0.000029956  ) * t\n+//             -    0.00000044   ) * t\n+//             +    1.3915817    ) * t\n+//             + 4612.156534     ) * t)\n+//     gst = fmod((st/3600.0 + theta), 360.0) / 15.0\n+//     if gst < 0.0:\n+//         gst += 24.0\n+//     # return sidereal hours in the half-open range [0, 24).\n+//     return gst\n+\n+// def era(time):        # Earth Rotation Angle\n+//     thet1 = 0.7790572732640 + 0.00273781191135448 * time.ut\n+//     thet3 = fmod(time.ut, 1.0)\n+//     theta = 360.0 * fmod((thet1 + thet3), 1.0)\n+//     if theta < 0.0:\n+//         theta += 360.0\n+//     return theta\n+\n+// def terra(observer, st):\n+//     return terra_posvel(observer, st)[0:3]\n+\n+// def geo_pos(time, observer):\n+//     gast = sidereal_time(time)\n+//     pos1 = terra(observer, gast)\n+//     pos2 = nutation(pos1, time, PrecessDir.Into2000)\n+//     outpos = precession(pos2, time, PrecessDir.Into2000)\n+//     return outpos\n+\n+// def nutation(pos, time, direction):\n+//     r = nutation_rot(time, direction)\n+//     return rotate(r, pos)\n+\n+// class e_tilt:\n+//     def __init__(self, time):\n+//         e = iau2000b(time)\n+//         self.dpsi = e.dpsi\n+//         self.deps = e.deps\n+//         self.mobl = mean_obliq(time.tt)\n+//         self.tobl = self.mobl + (e.deps / 3600.0)\n+//         self.tt = time\n+//         self.ee = e.dpsi * cos(radians(self.mobl)) / 15.0\n+\n+// def nutation_rot(time, direction):\n+//     tilt = time._etilt()\n+//     oblm = radians(tilt.mobl)\n+//     oblt = radians(tilt.tobl)\n+//     psi = tilt.dpsi * ASEC2RAD\n+//     cobm = cos(oblm)\n+//     sobm = sin(oblm)\n+//     cobt = cos(oblt)\n+//     sobt = sin(oblt)\n+//     cpsi = cos(psi)\n+//     spsi = sin(psi)\n+\n+//     xx = cpsi\n+//     yx = -spsi * cobm\n+//     zx = -spsi * sobm\n+//     xy = spsi * cobt\n+//     yy = cpsi * cobm * cobt + sobm * sobt\n+//     zy = cpsi * sobm * cobt - cobm * sobt\n+//     xz = spsi * sobt\n+//     yz = cpsi * cobm * sobt - sobm * cobt\n+//     zz = cpsi * sobm * sobt + cobm * cobt\n+\n+//     if direction == PrecessDir.From2000:\n+//         # convert J2000 to of-date\n+//         return RotationMatrix([\n+//             [xx, xy, xz],\n+//             [yx, yy, yz],\n+//             [zx, zy, zz]\n+//         ])\n+\n+//     if direction == PrecessDir.Into2000:\n+//         # convert of-date to J2000\n+//         return RotationMatrix([\n+//             [xx, yx, zx],\n+//             [xy, yy, zy],\n+//             [xz, yz, zz]\n+//         ])\n+\n+//     raise Error('Invalid nutation direction')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1642936226027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -166,9 +166,30 @@\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n \n+void iau2000b(double time) {\n+  double t, el, elp, f, d, om, dp, de, arg, sarg, carg, dpsi, deps;\n+  t = time / 36525.0;\n+  el = fmod((485868.249036 + t * 1717915923.2178), asec360) * asec2rad;\n+  elp = fmod((1287104.79305 + t * 129596581.0481), asec360) * asec2rad;\n+  f = fmod((335779.526232 + t * 1739527262.8478), asec360) * asec2rad;\n+  d = fmod((1072260.70369 + t * 1602961601.2090), asec360) * asec2rad;\n+  om = fmod((450160.398036 - t * 6962890.5431), asec360) * asec2rad;\n+  dp = 0;\n+  de = 0;\n \n+  arg = 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(om);\n+  carg = cos(om);\n+\n+  dpsi = -0.000135 + (dp * 1.0e-7);\n+  deps = 0.000388 + (de * 1.0e-7);\n+\n+  dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n+  de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n+}\n+\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n"
                },
                {
                    "date": 1642936264820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n // Ready\n // ------\n import 'dart:math';\n import 'classes.dart';\n+import 'constants.dart';\n \n const asec2rad = 4.848136811095359935899141e-6;\n \n double radians(double rad) => rad * pi / 180;\n"
                },
                {
                    "date": 1642936297055,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,9 +167,9 @@\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n \n-void iau2000b(double time) {\n+Iau2000b iau2000b(double time) {\n   double t, el, elp, f, d, om, dp, de, arg, sarg, carg, dpsi, deps;\n   t = time / 36525.0;\n   el = fmod((485868.249036 + t * 1717915923.2178), asec360) * asec2rad;\n   elp = fmod((1287104.79305 + t * 129596581.0481), asec360) * asec2rad;\n"
                },
                {
                    "date": 1642936575015,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,8 +187,9 @@\n   deps = 0.000388 + (de * 1.0e-7);\n \n   dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n   de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n+  return Iau2000b(time);\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642936681360,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,9 +187,9 @@\n   deps = 0.000388 + (de * 1.0e-7);\n \n   dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n   de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n-  return Iau2000b(time);\n+  return Iau2000b(dpsi, deps);\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642937364253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,9 +187,13 @@\n   deps = 0.000388 + (de * 1.0e-7);\n \n   dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n   de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n-  return Iau2000b(dpsi, deps);\n+  return Iau2000b(\n+    de: de,\n+    deps: deps,\n+    dp: dp,\n+  );\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642937429616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -190,9 +190,8 @@\n   de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n   return Iau2000b(\n     de: de,\n     deps: deps,\n-    dp: dp,\n   );\n }\n \n // def vector2radec(pos, time):\n"
                },
                {
                    "date": 1642937677415,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,8 +187,9 @@\n   deps = 0.000388 + (de * 1.0e-7);\n \n   dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n   de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n+\n   return Iau2000b(\n     de: de,\n     deps: deps,\n   );\n"
                },
                {
                    "date": 1642938104187,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,12 +188,9 @@\n \n   dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n   de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n \n-  return Iau2000b(\n-    de: de,\n-    deps: deps,\n-  );\n+  return Iau2000b(deps: deps, dpsi: dpsi);\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642938909422,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,30 +167,11 @@\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n \n-Iau2000b iau2000b(double time) {\n+class Iau2000b {\n+  var e = iau2000b(time);\n   double t, el, elp, f, d, om, dp, de, arg, sarg, carg, dpsi, deps;\n-  t = time / 36525.0;\n-  el = fmod((485868.249036 + t * 1717915923.2178), asec360) * asec2rad;\n-  elp = fmod((1287104.79305 + t * 129596581.0481), asec360) * asec2rad;\n-  f = fmod((335779.526232 + t * 1739527262.8478), asec360) * asec2rad;\n-  d = fmod((1072260.70369 + t * 1602961601.2090), asec360) * asec2rad;\n-  om = fmod((450160.398036 - t * 6962890.5431), asec360) * asec2rad;\n-  dp = 0;\n-  de = 0;\n-\n-  arg = 2.0 * f - 2.0 * d + 2.0 * om;\n-  sarg = sin(om);\n-  carg = cos(om);\n-\n-  dpsi = -0.000135 + (dp * 1.0e-7);\n-  deps = 0.000388 + (de * 1.0e-7);\n-\n-  dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n-  de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n-\n-  return Iau2000b(deps: deps, dpsi: dpsi);\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642939024175,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,10 +168,11 @@\n   return rotate(r, pos);\n }\n \n class Iau2000b {\n-  var e = iau2000b(time);\n-  double t, el, elp, f, d, om, dp, de, arg, sarg, carg, dpsi, deps;\n+  List e = iau2000b;\n+  var dpsi = e[0];\n+  var deps = e[1];\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642939218760,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,8 +168,9 @@\n   return rotate(r, pos);\n }\n \n class Iau2000b {\n+  Iau2000b(this.dpsi, this.deps);\n   List e = iau2000b;\n   var dpsi = e[0];\n   var deps = e[1];\n }\n"
                },
                {
                    "date": 1642939468602,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,11 +169,11 @@\n }\n \n class Iau2000b {\n   Iau2000b(this.dpsi, this.deps);\n-  List e = iau2000b;\n-  var dpsi = e[0];\n-  var deps = e[1];\n+  // List e = iau2000b;\n+  double dpsi;\n+  double deps;\n }\n \n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n"
                },
                {
                    "date": 1642939529935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,9 +169,8 @@\n }\n \n class Iau2000b {\n   Iau2000b(this.dpsi, this.deps);\n-  // List e = iau2000b;\n   double dpsi;\n   double deps;\n }\n \n"
                },
                {
                    "date": 1642939597154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,14 +167,10 @@\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n \n-class Iau2000b {\n-  Iau2000b(this.dpsi, this.deps);\n-  double dpsi;\n-  double deps;\n-}\n \n+\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n"
                },
                {
                    "date": 1642939670850,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,12 +2,9 @@\n // Ready\n // ------\n import 'dart:math';\n import 'classes.dart';\n-import 'constants.dart';\n \n-const asec2rad = 4.848136811095359935899141e-6;\n-\n double radians(double rad) => rad * pi / 180;\n double degrees(double grad) => grad / pi * 180;\n double fmod(double x, double y) => x - (x / y).truncate() * y;\n \n"
                },
                {
                    "date": 1642940093686,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,9 @@\n // Ready\n // ------\n import 'dart:math';\n import 'classes.dart';\n+import 'constants.dart';\n \n double radians(double rad) => rad * pi / 180;\n double degrees(double grad) => grad / pi * 180;\n double fmod(double x, double y) => x - (x / y).truncate() * y;\n"
                },
                {
                    "date": 1642940580886,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -248,18 +248,10 @@\n // def nutation(pos, time, direction):\n //     r = nutation_rot(time, direction)\n //     return rotate(r, pos)\n \n-// class e_tilt:\n-//     def __init__(self, time):\n-//         e = iau2000b(time)\n-//         self.dpsi = e.dpsi\n-//         self.deps = e.deps\n-//         self.mobl = mean_obliq(time.tt)\n-//         self.tobl = self.mobl + (e.deps / 3600.0)\n-//         self.tt = time\n-//         self.ee = e.dpsi * cos(radians(self.mobl)) / 15.0\n \n+\n // def nutation_rot(time, direction):\n //     tilt = time._etilt()\n //     oblm = radians(tilt.mobl)\n //     oblt = radians(tilt.tobl)\n"
                },
                {
                    "date": 1642940626186,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -130,10 +130,8 @@\n     ]);\n   }\n }\n \n-//     raise Error('Inalid precession direction')\n-\n double meanObliq(time) {\n   double t = time / 36525;\n   double asec =\n       (((((-0.0000000434 * t - 0.000000576) * t + 0.00200340) * t - 0.0001831) *\n"
                },
                {
                    "date": 1642940766236,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -163,10 +163,52 @@\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n }\n \n+List nutation(pos, time, direction) {\n+    var r = nutationRot(time, direction)\n+    return rotate(r, pos);}\n \n+// def nutationRot(time, direction):\n+//     tilt = time._etilt()\n+//     oblm = radians(tilt.mobl)\n+//     oblt = radians(tilt.tobl)\n+//     psi = tilt.dpsi * ASEC2RAD\n+//     cobm = cos(oblm)\n+//     sobm = sin(oblm)\n+//     cobt = cos(oblt)\n+//     sobt = sin(oblt)\n+//     cpsi = cos(psi)\n+//     spsi = sin(psi)\n \n+//     xx = cpsi\n+//     yx = -spsi * cobm\n+//     zx = -spsi * sobm\n+//     xy = spsi * cobt\n+//     yy = cpsi * cobm * cobt + sobm * sobt\n+//     zy = cpsi * sobm * cobt - cobm * sobt\n+//     xz = spsi * sobt\n+//     yz = cpsi * cobm * sobt - sobm * cobt\n+//     zz = cpsi * sobm * sobt + cobm * cobt\n+\n+//     if direction == PrecessDir.From2000:\n+//         # convert J2000 to of-date\n+//         return RotationMatrix([\n+//             [xx, xy, xz],\n+//             [yx, yy, yz],\n+//             [zx, zy, zz]\n+//         ])\n+\n+//     if direction == PrecessDir.Into2000:\n+//         # convert of-date to J2000\n+//         return RotationMatrix([\n+//             [xx, yx, zx],\n+//             [xy, yy, zy],\n+//             [xz, yz, zz]\n+//         ])\n+\n+//     raise Error('Invalid nutation direction')\n+\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n@@ -242,49 +284,4 @@\n //     pos2 = nutation(pos1, time, PrecessDir.Into2000)\n //     outpos = precession(pos2, time, PrecessDir.Into2000)\n //     return outpos\n \n-// def nutation(pos, time, direction):\n-//     r = nutation_rot(time, direction)\n-//     return rotate(r, pos)\n-\n-\n-\n-// def nutation_rot(time, direction):\n-//     tilt = time._etilt()\n-//     oblm = radians(tilt.mobl)\n-//     oblt = radians(tilt.tobl)\n-//     psi = tilt.dpsi * ASEC2RAD\n-//     cobm = cos(oblm)\n-//     sobm = sin(oblm)\n-//     cobt = cos(oblt)\n-//     sobt = sin(oblt)\n-//     cpsi = cos(psi)\n-//     spsi = sin(psi)\n-\n-//     xx = cpsi\n-//     yx = -spsi * cobm\n-//     zx = -spsi * sobm\n-//     xy = spsi * cobt\n-//     yy = cpsi * cobm * cobt + sobm * sobt\n-//     zy = cpsi * sobm * cobt - cobm * sobt\n-//     xz = spsi * sobt\n-//     yz = cpsi * cobm * sobt - sobm * cobt\n-//     zz = cpsi * sobm * sobt + cobm * cobt\n-\n-//     if direction == PrecessDir.From2000:\n-//         # convert J2000 to of-date\n-//         return RotationMatrix([\n-//             [xx, xy, xz],\n-//             [yx, yy, yz],\n-//             [zx, zy, zz]\n-//         ])\n-\n-//     if direction == PrecessDir.Into2000:\n-//         # convert of-date to J2000\n-//         return RotationMatrix([\n-//             [xx, yx, zx],\n-//             [xy, yy, zy],\n-//             [xz, yz, zz]\n-//         ])\n-\n-//     raise Error('Invalid nutation direction')\n\\ No newline at end of file\n"
                },
                {
                    "date": 1642940923838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -167,48 +167,48 @@\n List nutation(pos, time, direction) {\n     var r = nutationRot(time, direction)\n     return rotate(r, pos);}\n \n-// def nutationRot(time, direction):\n-//     tilt = time._etilt()\n-//     oblm = radians(tilt.mobl)\n-//     oblt = radians(tilt.tobl)\n-//     psi = tilt.dpsi * ASEC2RAD\n-//     cobm = cos(oblm)\n-//     sobm = sin(oblm)\n-//     cobt = cos(oblt)\n-//     sobt = sin(oblt)\n-//     cpsi = cos(psi)\n-//     spsi = sin(psi)\n+RotationMatrix nutationRot(time, direction)\n+    tilt = time._etilt();\n+    oblm = radians(tilt.mobl);\n+    oblt = radians(tilt.tobl);\n+    psi = tilt.dpsi * ASEC2RAD;\n+    cobm = cos(oblm);\n+    sobm = sin(oblm);\n+    cobt = cos(oblt);\n+    sobt = sin(oblt);\n+    cpsi = cos(psi);\n+    spsi = sin(psi);\n \n-//     xx = cpsi\n-//     yx = -spsi * cobm\n-//     zx = -spsi * sobm\n-//     xy = spsi * cobt\n-//     yy = cpsi * cobm * cobt + sobm * sobt\n-//     zy = cpsi * sobm * cobt - cobm * sobt\n-//     xz = spsi * sobt\n-//     yz = cpsi * cobm * sobt - sobm * cobt\n-//     zz = cpsi * sobm * sobt + cobm * cobt\n+    xx = cpsi;\n+    yx = -spsi * cobm;\n+    zx = -spsi * sobm;\n+    xy = spsi * cobt;\n+    yy = cpsi * cobm * cobt + sobm * sobt;\n+    zy = cpsi * sobm * cobt - cobm * sobt;\n+    xz = spsi * sobt;\n+    yz = cpsi * cobm * sobt - sobm * cobt;\n+    zz = cpsi * sobm * sobt + cobm * cobt;\n \n-//     if direction == PrecessDir.From2000:\n-//         # convert J2000 to of-date\n-//         return RotationMatrix([\n-//             [xx, xy, xz],\n-//             [yx, yy, yz],\n-//             [zx, zy, zz]\n-//         ])\n+    if (direction == PrecessDir.From2000)\n+        // convert J2000 to of-date\n+        return RotationMatrix([\n+            [xx, xy, xz],\n+            [yx, yy, yz],\n+            [zx, zy, zz]\n+        ]);\n \n-//     if direction == PrecessDir.Into2000:\n-//         # convert of-date to J2000\n-//         return RotationMatrix([\n-//             [xx, yx, zx],\n-//             [xy, yy, zy],\n-//             [xz, yz, zz]\n-//         ])\n+    if (direction == PrecessDir.Into2000)\n+        // convert of-date to J2000\n+        return RotationMatrix([\n+            [xx, yx, zx],\n+            [xy, yy, zy],\n+            [xz, yz, zz]\n+        ]);\n \n-//     raise Error('Invalid nutation direction')\n \n+\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n"
                },
                {
                    "date": 1642941045660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,9 +168,9 @@\n     var r = nutationRot(time, direction)\n     return rotate(r, pos);}\n \n RotationMatrix nutationRot(time, direction)\n-    tilt = time._etilt();\n+    tilt = iau2000b;\n     oblm = radians(tilt.mobl);\n     oblt = radians(tilt.tobl);\n     psi = tilt.dpsi * ASEC2RAD;\n     cobm = cos(oblm);\n"
                },
                {
                    "date": 1642941167032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,9 +168,9 @@\n     var r = nutationRot(time, direction)\n     return rotate(r, pos);}\n \n RotationMatrix nutationRot(time, direction)\n-    tilt = iau2000b;\n+    var tilt = iau2000b(time);\n     oblm = radians(tilt.mobl);\n     oblt = radians(tilt.tobl);\n     psi = tilt.dpsi * ASEC2RAD;\n     cobm = cos(oblm);\n@@ -199,13 +199,13 @@\n         ]);\n \n     if (direction == PrecessDir.Into2000)\n         // convert of-date to J2000\n-        return RotationMatrix([\n+        {return RotationMatrix([\n             [xx, yx, zx],\n             [xy, yy, zy],\n             [xz, yz, zz]\n-        ]);\n+        ]);}\n \n \n \n // def vector2radec(pos, time):\n"
                },
                {
                    "date": 1642941284273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -168,44 +168,44 @@\n     var r = nutationRot(time, direction)\n     return rotate(r, pos);}\n \n RotationMatrix nutationRot(time, direction)\n-    var tilt = iau2000b(time);\n-    oblm = radians(tilt.mobl);\n-    oblt = radians(tilt.tobl);\n-    psi = tilt.dpsi * ASEC2RAD;\n-    cobm = cos(oblm);\n-    sobm = sin(oblm);\n-    cobt = cos(oblt);\n-    sobt = sin(oblt);\n-    cpsi = cos(psi);\n-    spsi = sin(psi);\n+    {var tilt = iau2000b(time);\n+    var oblm = radians(tilt.mobl);\n+    var oblt = radians(tilt.tobl);\n+    var psi = tilt.dpsi * asec2rad;\n+    var cobm = cos(oblm);\n+    var sobm = sin(oblm);\n+    var cobt = cos(oblt);\n+    var sobt = sin(oblt);\n+    var cpsi = cos(psi);\n+    var spsi = sin(psi);\n \n-    xx = cpsi;\n-    yx = -spsi * cobm;\n-    zx = -spsi * sobm;\n-    xy = spsi * cobt;\n-    yy = cpsi * cobm * cobt + sobm * sobt;\n-    zy = cpsi * sobm * cobt - cobm * sobt;\n-    xz = spsi * sobt;\n-    yz = cpsi * cobm * sobt - sobm * cobt;\n-    zz = cpsi * sobm * sobt + cobm * cobt;\n+    var xx = cpsi;\n+    var yx = -spsi * cobm;\n+    var zx = -spsi * sobm;\n+    var xy = spsi * cobt;\n+    var yy = cpsi * cobm * cobt + sobm * sobt;\n+    var zy = cpsi * sobm * cobt - cobm * sobt;\n+    var xz = spsi * sobt;\n+    var yz = cpsi * cobm * sobt - sobm * cobt;\n+    var zz = cpsi * sobm * sobt + cobm * cobt;\n \n     if (direction == PrecessDir.From2000)\n         // convert J2000 to of-date\n-        return RotationMatrix([\n+       { return RotationMatrix([\n             [xx, xy, xz],\n             [yx, yy, yz],\n             [zx, zy, zz]\n-        ]);\n+        ]);}\n \n-    if (direction == PrecessDir.Into2000)\n+    else if (direction == PrecessDir.Into2000)\n         // convert of-date to J2000\n         {return RotationMatrix([\n             [xx, yx, zx],\n             [xy, yy, zy],\n             [xz, yz, zz]\n-        ]);}\n+        ]);}}\n \n \n \n // def vector2radec(pos, time):\n"
                },
                {
                    "date": 1642941527443,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,17 +189,18 @@\n     var xz = spsi * sobt;\n     var yz = cpsi * cobm * sobt - sobm * cobt;\n     var zz = cpsi * sobm * sobt + cobm * cobt;\n \n-    if (direction == PrecessDir.From2000)\n+    if (direction == PrecessDir.from2000)\n         // convert J2000 to of-date\n        { return RotationMatrix([\n             [xx, xy, xz],\n             [yx, yy, yz],\n             [zx, zy, zz]\n         ]);}\n \n-    else if (direction == PrecessDir.Into2000)\n+    else \n+    // if (direction == PrecessDir.into2000)\n         // convert of-date to J2000\n         {return RotationMatrix([\n             [xx, yx, zx],\n             [xy, yy, zy],\n"
                },
                {
                    "date": 1642941541326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -164,52 +164,56 @@\n   return rotate(r, pos);\n }\n \n List nutation(pos, time, direction) {\n-    var r = nutationRot(time, direction)\n-    return rotate(r, pos);}\n+  var r = nutationRot(time, direction);\n+  return rotate(r, pos);\n+}\n \n-RotationMatrix nutationRot(time, direction)\n-    {var tilt = iau2000b(time);\n-    var oblm = radians(tilt.mobl);\n-    var oblt = radians(tilt.tobl);\n-    var psi = tilt.dpsi * asec2rad;\n-    var cobm = cos(oblm);\n-    var sobm = sin(oblm);\n-    var cobt = cos(oblt);\n-    var sobt = sin(oblt);\n-    var cpsi = cos(psi);\n-    var spsi = sin(psi);\n+RotationMatrix nutationRot(time, direction) {\n+  var tilt = iau2000b(time);\n+  var oblm = radians(tilt.mobl);\n+  var oblt = radians(tilt.tobl);\n+  var psi = tilt.dpsi * asec2rad;\n+  var cobm = cos(oblm);\n+  var sobm = sin(oblm);\n+  var cobt = cos(oblt);\n+  var sobt = sin(oblt);\n+  var cpsi = cos(psi);\n+  var spsi = sin(psi);\n \n-    var xx = cpsi;\n-    var yx = -spsi * cobm;\n-    var zx = -spsi * sobm;\n-    var xy = spsi * cobt;\n-    var yy = cpsi * cobm * cobt + sobm * sobt;\n-    var zy = cpsi * sobm * cobt - cobm * sobt;\n-    var xz = spsi * sobt;\n-    var yz = cpsi * cobm * sobt - sobm * cobt;\n-    var zz = cpsi * sobm * sobt + cobm * cobt;\n+  var xx = cpsi;\n+  var yx = -spsi * cobm;\n+  var zx = -spsi * sobm;\n+  var xy = spsi * cobt;\n+  var yy = cpsi * cobm * cobt + sobm * sobt;\n+  var zy = cpsi * sobm * cobt - cobm * sobt;\n+  var xz = spsi * sobt;\n+  var yz = cpsi * cobm * sobt - sobm * cobt;\n+  var zz = cpsi * sobm * sobt + cobm * cobt;\n \n-    if (direction == PrecessDir.from2000)\n-        // convert J2000 to of-date\n-       { return RotationMatrix([\n-            [xx, xy, xz],\n-            [yx, yy, yz],\n-            [zx, zy, zz]\n-        ]);}\n+  if (direction == PrecessDir.from2000)\n+  // convert J2000 to of-date\n+  {\n+    return RotationMatrix([\n+      [xx, xy, xz],\n+      [yx, yy, yz],\n+      [zx, zy, zz]\n+    ]);\n+  } else\n+  // if (direction == PrecessDir.into2000)\n+  // convert of-date to J2000\n+  {\n+    return RotationMatrix([\n+      [xx, yx, zx],\n+      [xy, yy, zy],\n+      [xz, yz, zz]\n+    ]);\n+  }\n+}\n \n-    else \n-    // if (direction == PrecessDir.into2000)\n-        // convert of-date to J2000\n-        {return RotationMatrix([\n-            [xx, yx, zx],\n-            [xy, yy, zy],\n-            [xz, yz, zz]\n-        ]);}}\n \n \n-\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n"
                },
                {
                    "date": 1642941771066,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,10 +210,30 @@\n     ]);\n   }\n }\n \n+dynamic geo_pos(time, observer)\n+    {var gast = sidereal_time(time);\n+    var pos1 = terra(observer, gast);\n+    var pos2 = nutation(pos1, time, PrecessDir.into2000);\n+    var outpos = precession(pos2, time, PrecessDir.into2000);\n+    return outpos;}\n \n+dynamic terra(observer, st)\n+   { return terraPosvel(observer, st)[0:3];}\n \n+dynamic era(time)        // Earth Rotation Angle\n+    {var thet1 = 0.7790572732640 + 0.00273781191135448 * time;\n+    var thet3 = fmod(time, 1.0);\n+    var theta = 360.0 * fmod((thet1 + thet3), 1.0);\n+    if (theta < 0.0)\n+        {theta += 360.0;}\n+    return theta;}\n+\n+\n+\n+\n+\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n@@ -271,22 +291,6 @@\n //         gst += 24.0\n //     # return sidereal hours in the half-open range [0, 24).\n //     return gst\n \n-// def era(time):        # Earth Rotation Angle\n-//     thet1 = 0.7790572732640 + 0.00273781191135448 * time.ut\n-//     thet3 = fmod(time.ut, 1.0)\n-//     theta = 360.0 * fmod((thet1 + thet3), 1.0)\n-//     if theta < 0.0:\n-//         theta += 360.0\n-//     return theta\n \n-// def terra(observer, st):\n-//     return terra_posvel(observer, st)[0:3]\n \n-// def geo_pos(time, observer):\n-//     gast = sidereal_time(time)\n-//     pos1 = terra(observer, gast)\n-//     pos2 = nutation(pos1, time, PrecessDir.Into2000)\n-//     outpos = precession(pos2, time, PrecessDir.Into2000)\n-//     return outpos\n-\n"
                },
                {
                    "date": 1642941848127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,25 +210,30 @@\n     ]);\n   }\n }\n \n-dynamic geo_pos(time, observer)\n-    {var gast = sidereal_time(time);\n-    var pos1 = terra(observer, gast);\n-    var pos2 = nutation(pos1, time, PrecessDir.into2000);\n-    var outpos = precession(pos2, time, PrecessDir.into2000);\n-    return outpos;}\n+dynamic geo_pos(time, observer) {\n+  var gast = sidereal_time(time);\n+  var pos1 = terra(observer, gast);\n+  var pos2 = nutation(pos1, time, PrecessDir.into2000);\n+  var outpos = precession(pos2, time, PrecessDir.into2000);\n+  return outpos;\n+}\n \n-dynamic terra(observer, st)\n-   { return terraPosvel(observer, st)[0:3];}\n+dynamic terra(observer, st) {\n+  return terraPosvel(observer, st);\n+}\n \n-dynamic era(time)        // Earth Rotation Angle\n-    {var thet1 = 0.7790572732640 + 0.00273781191135448 * time;\n-    var thet3 = fmod(time, 1.0);\n-    var theta = 360.0 * fmod((thet1 + thet3), 1.0);\n-    if (theta < 0.0)\n-        {theta += 360.0;}\n-    return theta;}\n+dynamic era(time) // Earth Rotation Angle\n+{\n+  var thet1 = 0.7790572732640 + 0.00273781191135448 * time;\n+  var thet3 = fmod(time, 1.0);\n+  var theta = 360.0 * fmod((thet1 + thet3), 1.0);\n+  if (theta < 0.0) {\n+    theta += 360.0;\n+  }\n+  return theta;\n+}\n \n \n \n \n"
                },
                {
                    "date": 1642942053770,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,9 +211,9 @@\n   }\n }\n \n dynamic geo_pos(time, observer) {\n-  var gast = sidereal_time(time);\n+  var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n   return outpos;\n@@ -233,12 +233,8 @@\n   }\n   return theta;\n }\n \n-\n-\n-\n-\n // def vector2radec(pos, time):\n //     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n //     dist = sqrt(xyproj + pos[2]*pos[2])\n //     if xyproj == 0.0:\n@@ -257,9 +253,8 @@\n //         dec = degrees(atan2(pos[2], sqrt(xyproj)))\n //     vec = Vector(pos[0], pos[1], pos[2], time)\n //     return vec#Equatorial(ra, dec, dist, vec)\n \n-\n // def terra_posvel(observer, st):\n //     df2 = EARTH_FLATTENING ** 2\n //     phi = radians(observer.latitude)\n //     sinphi = sin(phi)\n@@ -279,23 +274,18 @@\n //         -ANGVEL * ach * cosphi * sinst * 86400 / KM_PER_AU,\n //         ANGVEL * ach * cosphi * cosst * 86400 / KM_PER_AU,\n //         0.0\n //     ]\n-// def sidereal_time(time):\n-//     t = time.tt / 36525.0\n-//     # eqeq = 15.0 * time._etilt().ee    # Replace with eqeq=0 to get GMST instead of GAST (if we ever need it)\n-//     eqeq = 0\n-//     theta = era(time)\n-//     st = (eqeq + 0.014506 +\n-//         (((( -    0.0000000368   * t\n-//             -    0.000029956  ) * t\n-//             -    0.00000044   ) * t\n-//             +    1.3915817    ) * t\n-//             + 4612.156534     ) * t)\n-//     gst = fmod((st/3600.0 + theta), 360.0) / 15.0\n-//     if gst < 0.0:\n-//         gst += 24.0\n-//     # return sidereal hours in the half-open range [0, 24).\n-//     return gst\n-\n-\n-\n+dynamic siderealTime(time) {\n+  var t = time / 36525.0;\n+  var theta = era(time);\n+  var st = (0.014506 +\n+      ((((-0.0000000368 * t - 0.000029956) * t - 0.00000044) * t + 1.3915817) *\n+                  t +\n+              4612.156534) *\n+          t);\n+  var gst = fmod((st / 3600.0 + theta), 360.0) / 15.0;\n+  if (gst < 0.0) {\n+    gst += 24.0;\n+  }\n+  return gst;\n+}\n"
                },
                {
                    "date": 1642942158424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,29 +253,29 @@\n //         dec = degrees(atan2(pos[2], sqrt(xyproj)))\n //     vec = Vector(pos[0], pos[1], pos[2], time)\n //     return vec#Equatorial(ra, dec, dist, vec)\n \n-// def terra_posvel(observer, st):\n-//     df2 = EARTH_FLATTENING ** 2\n-//     phi = radians(observer.latitude)\n-//     sinphi = sin(phi)\n-//     cosphi = cos(phi)\n-//     c = 1.0 / sqrt(cosphi*cosphi + df2*sinphi*sinphi)\n-//     s = df2 * c\n-//     ht_km = observer.height / 1000.0\n-//     ach = EARTH_EQUATORIAL_RADIUS_KM*c + ht_km\n-//     ash = EARTH_EQUATORIAL_RADIUS_KM*s + ht_km\n-//     stlocl = radians(15.0*st + observer.longitude)\n-//     sinst = sin(stlocl)\n-//     cosst = cos(stlocl)\n-//     return [\n-//         ach * cosphi * cosst / KM_PER_AU,\n-//         ach * cosphi * sinst / KM_PER_AU,\n-//         ash * sinphi / KM_PER_AU,\n-//         -ANGVEL * ach * cosphi * sinst * 86400 / KM_PER_AU,\n-//         ANGVEL * ach * cosphi * cosst * 86400 / KM_PER_AU,\n-//         0.0\n-//     ]\n+List terra_posvel(observer, st)\n+{    var df2 = EARTH_FLATTENING ** 2;\n+    var phi = radians(observer.latitude);\n+    var sinphi = sin(phi);\n+    var cosphi = cos(phi);\n+    var c = 1.0 / sqrt(cosphi*cosphi + df2*sinphi*sinphi);\n+    var s = df2 * c;\n+    var ach = EARTH_EQUATORIAL_RADIUS_KM*c;\n+    var ash = EARTH_EQUATORIAL_RADIUS_KM*s;\n+    var stlocl = radians(15.0*st + observer.longitude);\n+    var sinst = sin(stlocl);\n+    var cosst = cos(stlocl);\n+    return [\n+        ach * cosphi * cosst / KM_PER_AU,\n+        ach * cosphi * sinst / KM_PER_AU,\n+        ash * sinphi / KM_PER_AU,\n+        -ANGVEL * ach * cosphi * sinst * 86400 / KM_PER_AU,\n+        ANGVEL * ach * cosphi * cosst * 86400 / KM_PER_AU,\n+        0.0\n+    ];}\n+\n dynamic siderealTime(time) {\n   var t = time / 36525.0;\n   var theta = era(time);\n   var st = (0.014506 +\n"
                },
                {
                    "date": 1642942318820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -254,9 +254,9 @@\n //     vec = Vector(pos[0], pos[1], pos[2], time)\n //     return vec#Equatorial(ra, dec, dist, vec)\n \n List terra_posvel(observer, st)\n-{    var df2 = EARTH_FLATTENING ** 2;\n+{    var df2 = earthFlattening ** 2;\n     var phi = radians(observer.latitude);\n     var sinphi = sin(phi);\n     var cosphi = cos(phi);\n     var c = 1.0 / sqrt(cosphi*cosphi + df2*sinphi*sinphi);\n"
                },
                {
                    "date": 1642942333146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -260,10 +260,10 @@\n     var sinphi = sin(phi);\n     var cosphi = cos(phi);\n     var c = 1.0 / sqrt(cosphi*cosphi + df2*sinphi*sinphi);\n     var s = df2 * c;\n-    var ach = EARTH_EQUATORIAL_RADIUS_KM*c;\n-    var ash = EARTH_EQUATORIAL_RADIUS_KM*s;\n+    var ach = earthEquatorialRadiusKM*c;\n+    var ash = earthEquatorialRadiusKM*s;\n     var stlocl = radians(15.0*st + observer.longitude);\n     var sinst = sin(stlocl);\n     var cosst = cos(stlocl);\n     return [\n"
                },
                {
                    "date": 1642942351208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -266,13 +266,13 @@\n     var stlocl = radians(15.0*st + observer.longitude);\n     var sinst = sin(stlocl);\n     var cosst = cos(stlocl);\n     return [\n-        ach * cosphi * cosst / KM_PER_AU,\n-        ach * cosphi * sinst / KM_PER_AU,\n-        ash * sinphi / KM_PER_AU,\n-        -ANGVEL * ach * cosphi * sinst * 86400 / KM_PER_AU,\n-        ANGVEL * ach * cosphi * cosst * 86400 / KM_PER_AU,\n+        ach * cosphi * cosst / kmPerAU,\n+        ach * cosphi * sinst / kmPerAU,\n+        ash * sinphi / kmPerAU,\n+        -ANGVEL * ach * cosphi * sinst * 86400 / kmPerAU,\n+        ANGVEL * ach * cosphi * cosst * 86400 / kmPerAU,\n         0.0\n     ];}\n \n dynamic siderealTime(time) {\n"
                },
                {
                    "date": 1642942383074,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,28 +253,29 @@\n //         dec = degrees(atan2(pos[2], sqrt(xyproj)))\n //     vec = Vector(pos[0], pos[1], pos[2], time)\n //     return vec#Equatorial(ra, dec, dist, vec)\n \n-List terra_posvel(observer, st)\n-{    var df2 = earthFlattening ** 2;\n-    var phi = radians(observer.latitude);\n-    var sinphi = sin(phi);\n-    var cosphi = cos(phi);\n-    var c = 1.0 / sqrt(cosphi*cosphi + df2*sinphi*sinphi);\n-    var s = df2 * c;\n-    var ach = earthEquatorialRadiusKM*c;\n-    var ash = earthEquatorialRadiusKM*s;\n-    var stlocl = radians(15.0*st + observer.longitude);\n-    var sinst = sin(stlocl);\n-    var cosst = cos(stlocl);\n-    return [\n-        ach * cosphi * cosst / kmPerAU,\n-        ach * cosphi * sinst / kmPerAU,\n-        ash * sinphi / kmPerAU,\n-        -ANGVEL * ach * cosphi * sinst * 86400 / kmPerAU,\n-        ANGVEL * ach * cosphi * cosst * 86400 / kmPerAU,\n-        0.0\n-    ];}\n+List terra_posvel(observer, st) {\n+  var df2 = earthFlattening * earthFlattening;\n+  var phi = radians(observer.latitude);\n+  var sinphi = sin(phi);\n+  var cosphi = cos(phi);\n+  var c = 1.0 / sqrt(cosphi * cosphi + df2 * sinphi * sinphi);\n+  var s = df2 * c;\n+  var ach = earthEquatorialRadiusKM * c;\n+  var ash = earthEquatorialRadiusKM * s;\n+  var stlocl = radians(15.0 * st + observer.longitude);\n+  var sinst = sin(stlocl);\n+  var cosst = cos(stlocl);\n+  return [\n+    ach * cosphi * cosst / kmPerAU,\n+    ach * cosphi * sinst / kmPerAU,\n+    ash * sinphi / kmPerAU,\n+    -angvel * ach * cosphi * sinst * 86400 / kmPerAU,\n+    angvel * ach * cosphi * cosst * 86400 / kmPerAU,\n+    0.0\n+  ];\n+}\n \n dynamic siderealTime(time) {\n   var t = time / 36525.0;\n   var theta = era(time);\n"
                },
                {
                    "date": 1642942399599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,9 +253,9 @@\n //         dec = degrees(atan2(pos[2], sqrt(xyproj)))\n //     vec = Vector(pos[0], pos[1], pos[2], time)\n //     return vec#Equatorial(ra, dec, dist, vec)\n \n-List terra_posvel(observer, st) {\n+List terraPosvel(observer, st) {\n   var df2 = earthFlattening * earthFlattening;\n   var phi = radians(observer.latitude);\n   var sinphi = sin(phi);\n   var cosphi = cos(phi);\n"
                },
                {
                    "date": 1642942606690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,27 +233,28 @@\n   }\n   return theta;\n }\n \n-// def vector2radec(pos, time):\n-//     xyproj = pos[0]*pos[0] + pos[1]*pos[1]\n-//     dist = sqrt(xyproj + pos[2]*pos[2])\n-//     if xyproj == 0.0:\n-//         # if pos[2] == 0.0:\n-//         #     # Indeterminate coordinates: pos vector has zero length.\n-//         #     raise BadVectorError()\n-//         ra = 0.0\n-//         if pos[2] < 0.0:\n-//             dec = -90.0\n-//         else:\n-//             dec = +90.0\n-//     else:\n-//         ra = RAD2HOUR * atan2(pos[1], pos[0])\n-//         if ra < 0:\n-//             ra += 24\n-//         dec = degrees(atan2(pos[2], sqrt(xyproj)))\n-//     vec = Vector(pos[0], pos[1], pos[2], time)\n-//     return vec#Equatorial(ra, dec, dist, vec)\n+Vector vector2radec(pos, time){\n+double ra,dec;\n+    var xyproj = pos[0]*pos[0] + pos[1]*pos[1];\n+    var dist = sqrt(xyproj + pos[2]*pos[2]);\n+    if (xyproj == 0.0)\n+        // # if pos[2] == 0.0:\n+        // #     # Indeterminate coordinates: pos vector has zero length.\n+        // #     raise BadVectorError()\n+        ra = 0.0;\n+        if (pos[2] < 0.0)\n+            dec = -90.0;\n+        else\n+            dec = +90.0;\n+    else\n+        ra = RAD2HOUR * atan2(pos[1], pos[0]);\n+        if (ra < 0)\n+            ra += 24;\n+        dec = degrees(atan2(pos[2], sqrt(xyproj)));\n+    Vector vec = Vector(pos[0], pos[1], pos[2], time);\n+    return vec;}   //Equatorial(ra, dec, dist, vec)\n \n List terraPosvel(observer, st) {\n   var df2 = earthFlattening * earthFlattening;\n   var phi = radians(observer.latitude);\n"
                },
                {
                    "date": 1642942714740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,21 +241,22 @@\n     if (xyproj == 0.0)\n         // # if pos[2] == 0.0:\n         // #     # Indeterminate coordinates: pos vector has zero length.\n         // #     raise BadVectorError()\n-        ra = 0.0;\n+        {ra = 0.0;}\n         if (pos[2] < 0.0)\n-            dec = -90.0;\n-        else\n-            dec = +90.0;\n+            {dec = -90.0;}\n+        else if\n+            {dec = 90.0;}\n     else\n-        ra = RAD2HOUR * atan2(pos[1], pos[0]);\n+        {ra = rad2hour * atan2(pos[1], pos[0]);}\n         if (ra < 0)\n-            ra += 24;\n+            {ra += 24;}\n         dec = degrees(atan2(pos[2], sqrt(xyproj)));\n     Vector vec = Vector(pos[0], pos[1], pos[2], time);\n     return vec;}   //Equatorial(ra, dec, dist, vec)\n \n+\n List terraPosvel(observer, st) {\n   var df2 = earthFlattening * earthFlattening;\n   var phi = radians(observer.latitude);\n   var sinphi = sin(phi);\n"
                },
                {
                    "date": 1642942742717,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,11 +238,8 @@\n double ra,dec;\n     var xyproj = pos[0]*pos[0] + pos[1]*pos[1];\n     var dist = sqrt(xyproj + pos[2]*pos[2]);\n     if (xyproj == 0.0)\n-        // # if pos[2] == 0.0:\n-        // #     # Indeterminate coordinates: pos vector has zero length.\n-        // #     raise BadVectorError()\n         {ra = 0.0;}\n         if (pos[2] < 0.0)\n             {dec = -90.0;}\n         else if\n"
                },
                {
                    "date": 1642942774703,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -241,9 +241,9 @@\n     if (xyproj == 0.0)\n         {ra = 0.0;}\n         if (pos[2] < 0.0)\n             {dec = -90.0;}\n-        else if\n+        else\n             {dec = 90.0;}\n     else\n         {ra = rad2hour * atan2(pos[1], pos[0]);}\n         if (ra < 0)\n"
                },
                {
                    "date": 1642942783758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -238,9 +238,9 @@\n double ra,dec;\n     var xyproj = pos[0]*pos[0] + pos[1]*pos[1];\n     var dist = sqrt(xyproj + pos[2]*pos[2]);\n     if (xyproj == 0.0)\n-        {ra = 0.0;}\n+        {ra = 0.0;\n         if (pos[2] < 0.0)\n             {dec = -90.0;}\n         else\n             {dec = 90.0;}\n"
                },
                {
                    "date": 1642942805478,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,27 +233,30 @@\n   }\n   return theta;\n }\n \n-Vector vector2radec(pos, time){\n-double ra,dec;\n-    var xyproj = pos[0]*pos[0] + pos[1]*pos[1];\n-    var dist = sqrt(xyproj + pos[2]*pos[2]);\n-    if (xyproj == 0.0)\n-        {ra = 0.0;\n-        if (pos[2] < 0.0)\n-            {dec = -90.0;}\n-        else\n-            {dec = 90.0;}\n-    else\n-        {ra = rad2hour * atan2(pos[1], pos[0]);}\n-        if (ra < 0)\n-            {ra += 24;}\n-        dec = degrees(atan2(pos[2], sqrt(xyproj)));\n-    Vector vec = Vector(pos[0], pos[1], pos[2], time);\n-    return vec;}   //Equatorial(ra, dec, dist, vec)\n+Vector vector2radec(pos, time) {\n+  double ra, dec;\n+  var xyproj = pos[0] * pos[0] + pos[1] * pos[1];\n+  var dist = sqrt(xyproj + pos[2] * pos[2]);\n+  if (xyproj == 0.0) {\n+    ra = 0.0;\n+    if (pos[2] < 0.0) {\n+      dec = -90.0;\n+    } else {\n+      dec = 90.0;\n+    }\n+  } else {\n+    ra = rad2hour * atan2(pos[1], pos[0]);\n+  }\n+  if (ra < 0) {\n+    ra += 24;\n+  }\n+  dec = degrees(atan2(pos[2], sqrt(xyproj)));\n+  Vector vec = Vector(pos[0], pos[1], pos[2], time);\n+  return vec;\n+} //Equatorial(ra, dec, dist, vec)\n \n-\n List terraPosvel(observer, st) {\n   var df2 = earthFlattening * earthFlattening;\n   var phi = radians(observer.latitude);\n   var sinphi = sin(phi);\n"
                },
                {
                    "date": 1642942839979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -246,13 +246,14 @@\n       dec = 90.0;\n     }\n   } else {\n     ra = rad2hour * atan2(pos[1], pos[0]);\n+\n+    if (ra < 0) {\n+      ra += 24;\n+    }\n+    dec = degrees(atan2(pos[2], sqrt(xyproj)));\n   }\n-  if (ra < 0) {\n-    ra += 24;\n-  }\n-  dec = degrees(atan2(pos[2], sqrt(xyproj)));\n   Vector vec = Vector(pos[0], pos[1], pos[2], time);\n   return vec;\n } //Equatorial(ra, dec, dist, vec)\n \n"
                },
                {
                    "date": 1642942943113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,9 +210,9 @@\n     ]);\n   }\n }\n \n-dynamic geo_pos(time, observer) {\n+dynamic geoPos(time, observer) {\n   var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n"
                },
                {
                    "date": 1642992112489,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -292,4 +292,488 @@\n     gst += 24.0;\n   }\n   return gst;\n }\n+\n+Etilt iau2000b(double time) {\n+  double t, el, elp, f, d, om, dp, de, arg, sarg, carg, dpsi, deps;\n+  t = time / 36525.0;\n+  el = fmod((485868.249036 + t * 1717915923.2178), asec360) * asec2rad;\n+  elp = fmod((1287104.79305 + t * 129596581.0481), asec360) * asec2rad;\n+  f = fmod((335779.526232 + t * 1739527262.8478), asec360) * asec2rad;\n+  d = fmod((1072260.70369 + t * 1602961601.2090), asec360) * asec2rad;\n+  om = fmod((450160.398036 - t * 6962890.5431), asec360) * asec2rad;\n+  dp = 0;\n+  de = 0;\n+\n+  arg = 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(om);\n+  carg = cos(om);\n+\n+  dpsi = -0.000135 + (dp * 1.0e-7);\n+  deps = 0.000388 + (de * 1.0e-7);\n+\n+  dp = (-172064161.0 - 174666.0 * t) * sarg + 33386.0 * carg;\n+  de += (92052331.0 + 9086.0 * t) * carg + 15377.0 * sarg;\n+\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-13170906.0 - 1675.0 * t) * sarg - 13696.0 * carg;\n+  de += (5730336.0 - 3015.0 * t) * carg - 4587.0 * sarg;\n+\n+  arg = 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-2276413.0 - 234.0 * t) * sarg + 2796.0 * carg;\n+  de += (978459.0 - 485.0 * t) * carg + 1374.0 * sarg;\n+\n+  arg = 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (2074554.0 + 207.0 * t) * sarg - 698.0 * carg;\n+  de += (-897492.0 + 470.0 * t) * carg - 291.0 * sarg;\n+\n+  sarg = sin(elp);\n+  carg = cos(elp);\n+  dp += (1475877.0 - 3633.0 * t) * sarg + 11817.0 * carg;\n+  de += (73871.0 - 184.0 * t) * carg - 1924.0 * sarg;\n+\n+  arg = elp + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-516821.0 + 1226.0 * t) * sarg - 524.0 * carg;\n+  de += (224386.0 - 677.0 * t) * carg - 174.0 * sarg;\n+\n+  sarg = sin(el);\n+  carg = cos(el);\n+  dp += (711159.0 + 73.0 * t) * sarg - 872.0 * carg;\n+  de += (-6750.0) * carg + 358.0 * sarg;\n+\n+  arg = 2.0 * f + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-387298.0 - 367.0 * t) * sarg + 380.0 * carg;\n+  de += (200728.0 + 18.0 * t) * carg + 318.0 * sarg;\n+\n+  arg = el + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-301461.0 - 36.0 * t) * sarg + 816.0 * carg;\n+  de += (129025.0 - 63.0 * t) * carg + 367.0 * sarg;\n+\n+  arg = -elp + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (215829.0 - 494.0 * t) * sarg + 111.0 * carg;\n+  de += (-95929.0 + 299.0 * t) * carg + 132.0 * sarg;\n+\n+  arg = 2.0 * f - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (128227.0 + 137.0 * t) * sarg + 181.0 * carg;\n+  de += (-68982.0 - 9.0 * t) * carg + 39.0 * sarg;\n+\n+  arg = -el + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (123457.0 + 11.0 * t) * sarg + 19.0 * carg;\n+  de += (-53311.0 + 32.0 * t) * carg - 4.0 * sarg;\n+\n+  arg = -el + 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (156994.0 + 10.0 * t) * sarg - 168.0 * carg;\n+  de += (-1235.0) * carg + 82.0 * sarg;\n+\n+  arg = el + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (63110.0 + 63.0 * t) * sarg + 27.0 * carg;\n+  de += (-33228.0) * carg - 9.0 * sarg;\n+\n+  arg = -el + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-57976.0 - 63.0 * t) * sarg - 189.0 * carg;\n+  de += (31429.0) * carg - 75.0 * sarg;\n+\n+  arg = -el + 2.0 * f + 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-59641.0 - 11.0 * t) * sarg + 149.0 * carg;\n+  de += (25543.0 - 11.0 * t) * carg + 66.0 * sarg;\n+\n+  arg = el + 2.0 * f + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-51613.0 - 42.0 * t) * sarg + 129.0 * carg;\n+  de += (26366.0) * carg + 78.0 * sarg;\n+\n+  arg = -2.0 * el + 2.0 * f + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (45893.0 + 50.0 * t) * sarg + 31.0 * carg;\n+  de += (-24236.0 - 10.0 * t) * carg + 20.0 * sarg;\n+\n+  arg = 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (63384.0 + 11.0 * t) * sarg - 150.0 * carg;\n+  de += (-1220.0) * carg + 29.0 * sarg;\n+\n+  arg = 2.0 * f + 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-38571.0 - 1.0 * t) * sarg + 158.0 * carg;\n+  de += (16452.0 - 11.0 * t) * carg + 68.0 * sarg;\n+\n+  arg = -2.0 * elp + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (32481.0) * sarg;\n+  de += (-13870.0) * carg;\n+\n+  arg = -2.0 * el + 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-47722.0) * sarg - 18.0 * carg;\n+  de += (477.0) * carg - 25.0 * sarg;\n+\n+  arg = 2.0 * el + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-31046.0 - 1.0 * t) * sarg + 131.0 * carg;\n+  de += (13238.0 - 11.0 * t) * carg + 59.0 * sarg;\n+\n+  arg = el + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (28593.0) * sarg - carg;\n+  de += (-12338.0 + 10.0 * t) * carg - 3.0 * sarg;\n+\n+  arg = -el + 2.0 * f + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (20441.0 + 21.0 * t) * sarg + 10.0 * carg;\n+  de += (-10758.0) * carg - 3.0 * sarg;\n+\n+  arg = 2.0 * el;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (29243.0) * sarg - 74.0 * carg;\n+  de += (-609.0) * carg + 13.0 * sarg;\n+\n+  arg = 2.0 * f;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (25887.0) * sarg - 66.0 * carg;\n+  de += (-550.0) * carg + 11.0 * sarg;\n+\n+  arg = elp + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-14053.0 - 25.0 * t) * sarg + 79.0 * carg;\n+  de += (8551.0 - 2.0 * t) * carg - 45.0 * sarg;\n+\n+  arg = -el + 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (15164.0 + 10.0 * t) * sarg + 11.0 * carg;\n+  de += (-8001.0) * carg - sarg;\n+\n+  arg = 2.0 * elp + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-15794.0 + 72.0 * t) * sarg - 16.0 * carg;\n+  de += (6850.0 - 42.0 * t) * carg - 5.0 * sarg;\n+\n+  arg = -2.0 * f + 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (21783.0) * sarg + 13.0 * carg;\n+  de += (-167.0) * carg + 13.0 * sarg;\n+\n+  arg = el - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-12873.0 - 10.0 * t) * sarg - 37.0 * carg;\n+  de += (6953.0) * carg - 14.0 * sarg;\n+\n+  arg = -elp + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-12654.0 + 11.0 * t) * sarg + 63.0 * carg;\n+  de += (6415.0) * carg + 26.0 * sarg;\n+\n+  arg = -el + 2.0 * f + 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-10204.0) * sarg + 25.0 * carg;\n+  de += (5222.0) * carg + 15.0 * sarg;\n+\n+  arg = 2.0 * elp;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (16707.0 - 85.0 * t) * sarg - 10.0 * carg;\n+  de += (168.0 - 1.0 * t) * carg + 10.0 * sarg;\n+\n+  arg = el + 2.0 * f + 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-7691.0) * sarg + 44.0 * carg;\n+  de += (3268.0) * carg + 19.0 * sarg;\n+\n+  arg = -2.0 * el + 2.0 * f;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-11024.0) * sarg - 14.0 * carg;\n+  de += (104.0) * carg + 2.0 * sarg;\n+\n+  arg = elp + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (7566.0 - 21.0 * t) * sarg - 11.0 * carg;\n+  de += (-3250.0) * carg - 5.0 * sarg;\n+\n+  arg = 2.0 * f + 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-6637.0 - 11.0 * t) * sarg + 25.0 * carg;\n+  de += (3353.0) * carg + 14.0 * sarg;\n+\n+  arg = -elp + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-7141.0 + 21.0 * t) * sarg + 8.0 * carg;\n+  de += (3070.0) * carg + 4.0 * sarg;\n+\n+  arg = 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-6302.0 - 11.0 * t) * sarg + 2.0 * carg;\n+  de += (3272.0) * carg + 4.0 * sarg;\n+\n+  arg = el + 2.0 * f - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (5800.0 + 10.0 * t) * sarg + 2.0 * carg;\n+  de += (-3045.0) * carg - sarg;\n+\n+  arg = 2.0 * el + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (6443.0) * sarg - 7.0 * carg;\n+  de += (-2768.0) * carg - 4.0 * sarg;\n+\n+  arg = -2.0 * el + 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-5774.0 - 11.0 * t) * sarg - 15.0 * carg;\n+  de += (3041.0) * carg - 5.0 * sarg;\n+\n+  arg = 2.0 * el + 2.0 * f + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-5350.0) * sarg + 21.0 * carg;\n+  de += (2695.0) * carg + 12.0 * sarg;\n+\n+  arg = -elp + 2.0 * f - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-4752.0 - 11.0 * t) * sarg - 3.0 * carg;\n+  de += (2719.0) * carg - 3.0 * sarg;\n+\n+  arg = -2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-4940.0 - 11.0 * t) * sarg - 21.0 * carg;\n+  de += (2720.0) * carg - 9.0 * sarg;\n+\n+  arg = -el - elp + 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (7350.0) * sarg - 8.0 * carg;\n+  de += (-51.0) * carg + 4.0 * sarg;\n+\n+  arg = 2.0 * el - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (4065.0) * sarg + 6.0 * carg;\n+  de += (-2206.0) * carg + sarg;\n+\n+  arg = el + 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (6579.0) * sarg - 24.0 * carg;\n+  de += (-199.0) * carg + 2.0 * sarg;\n+\n+  arg = elp + 2.0 * f - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (3579.0) * sarg + 5.0 * carg;\n+  de += (-1900.0) * carg + sarg;\n+\n+  arg = el - elp;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (4725.0) * sarg - 6.0 * carg;\n+  de += (-41.0) * carg + 3.0 * sarg;\n+\n+  arg = -2.0 * el + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-3075.0) * sarg - 2.0 * carg;\n+  de += (1313.0) * carg - sarg;\n+\n+  arg = 3.0 * el + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-2904.0) * sarg + 15.0 * carg;\n+  de += (1233.0) * carg + 7.0 * sarg;\n+\n+  arg = -elp + 2.0 * d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (4348.0) * sarg - 10.0 * carg;\n+  de += (-81.0) * carg + 2.0 * sarg;\n+\n+  arg = el - elp + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-2878.0) * sarg + 8.0 * carg;\n+  de += (1232.0) * carg + 4.0 * sarg;\n+\n+  sarg = sin(d);\n+  carg = cos(d);\n+  dp += (-4230.0) * sarg + 5.0 * carg;\n+  de += (-20.0) * carg - 2.0 * sarg;\n+\n+  arg = -el - elp + 2.0 * f + 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-2819.0) * sarg + 7.0 * carg;\n+  de += (1207.0) * carg + 3.0 * sarg;\n+\n+  arg = -el + 2.0 * f;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-4056.0) * sarg + 5.0 * carg;\n+  de += (40.0) * carg - 2.0 * sarg;\n+\n+  arg = -elp + 2.0 * f + 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-2647.0) * sarg + 11.0 * carg;\n+  de += (1129.0) * carg + 5.0 * sarg;\n+\n+  arg = -2.0 * el + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-2294.0) * sarg - 10.0 * carg;\n+  de += (1266.0) * carg - 4.0 * sarg;\n+\n+  arg = el + elp + 2.0 * f + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (2481.0) * sarg - 7.0 * carg;\n+  de += (-1062.0) * carg - 3.0 * sarg;\n+\n+  arg = 2.0 * el + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (2179.0) * sarg - 2.0 * carg;\n+  de += (-1129.0) * carg - 2.0 * sarg;\n+\n+  arg = -el + elp + d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (3276.0) * sarg + carg;\n+  de += (-9.0) * carg;\n+\n+  arg = el + elp;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-3389.0) * sarg + 5.0 * carg;\n+  de += (35.0) * carg - 2.0 * sarg;\n+\n+  arg = el + 2.0 * f;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (3339.0) * sarg - 13.0 * carg;\n+  de += (-107.0) * carg + sarg;\n+\n+  arg = -el + 2.0 * f - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-1987.0) * sarg - 6.0 * carg;\n+  de += (1073.0) * carg - 2.0 * sarg;\n+\n+  arg = el + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-1981.0) * sarg;\n+  de += (854.0) * carg;\n+\n+  arg = -el + d;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (4026.0) * sarg - 353.0 * carg;\n+  de += (-553.0) * carg - 139.0 * sarg;\n+\n+  arg = 2.0 * f + d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (1660.0) * sarg - 5.0 * carg;\n+  de += (-710.0) * carg - 2.0 * sarg;\n+\n+  arg = -el + 2.0 * f + 4.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-1521.0) * sarg + 9.0 * carg;\n+  de += (647.0) * carg + 4.0 * sarg;\n+\n+  arg = -el + elp + d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (1314.0) * sarg;\n+  de += (-700.0) * carg;\n+\n+  arg = -2.0 * elp + 2.0 * f - 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-1283.0) * sarg;\n+  de += (672.0) * carg;\n+\n+  arg = el + 2.0 * f + 2.0 * d + om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (-1331.0) * sarg + 8.0 * carg;\n+  de += (663.0) * carg + 4.0 * sarg;\n+\n+  arg = -2.0 * el + 2.0 * f + 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (1383.0) * sarg - 2.0 * carg;\n+  de += (-594.0) * carg - 2.0 * sarg;\n+\n+  arg = -el + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (1405.0) * sarg + 4.0 * carg;\n+  de += (-610.0) * carg + 2.0 * sarg;\n+\n+  arg = el + elp + 2.0 * f - 2.0 * d + 2.0 * om;\n+  sarg = sin(arg);\n+  carg = cos(arg);\n+  dp += (1290.0) * sarg;\n+  de += (-556.0) * carg;\n+\n+  dpsi = -0.000135 + (dp * 1.0e-7);\n+  deps = 0.000388 + (de * 1.0e-7);\n+\n+  double mobl = meanObliq(time);\n+  double tobl = mobl + (deps / 3600.0);\n+  double tt = time;\n+  double ee = dpsi * cos(radians(mobl)) / 15.0;\n+\n+  return Etilt(dpsi, deps, mobl, tobl, tt, ee);\n+}\n"
                },
                {
                    "date": 1642992408516,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -278,9 +278,9 @@\n     0.0\n   ];\n }\n \n-dynamic siderealTime(time) {\n+double siderealTime(time) {\n   var t = time / 36525.0;\n   var theta = era(time);\n   var st = (0.014506 +\n       ((((-0.0000000368 * t - 0.000029956) * t - 0.00000044) * t + 1.3915817) *\n"
                },
                {
                    "date": 1642993030933,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -210,21 +210,21 @@\n     ]);\n   }\n }\n \n-dynamic geoPos(time, observer) {\n+List geoPos(time, observer) {\n   var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n   return outpos;\n }\n \n-dynamic terra(observer, st) {\n+List terra(observer, st) {\n   return terraPosvel(observer, st);\n }\n \n-dynamic era(time) // Earth Rotation Angle\n+double era(time) // Earth Rotation Angle\n {\n   var thet1 = 0.7790572732640 + 0.00273781191135448 * time;\n   var thet3 = fmod(time, 1.0);\n   var theta = 360.0 * fmod((thet1 + thet3), 1.0);\n"
                },
                {
                    "date": 1642996967356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,8 +268,9 @@\n   var ash = earthEquatorialRadiusKM * s;\n   var stlocl = radians(15.0 * st + observer.longitude);\n   var sinst = sin(stlocl);\n   var cosst = cos(stlocl);\n+  print(ach * cosphi * cosst / kmPerAU);\n   return [\n     ach * cosphi * cosst / kmPerAU,\n     ach * cosphi * sinst / kmPerAU,\n     ash * sinphi / kmPerAU,\n"
                },
                {
                    "date": 1642997179914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,9 +268,9 @@\n   var ash = earthEquatorialRadiusKM * s;\n   var stlocl = radians(15.0 * st + observer.longitude);\n   var sinst = sin(stlocl);\n   var cosst = cos(stlocl);\n-  print(ach * cosphi * cosst / kmPerAU);\n+  print('$ach * $cosphi * $cosst / $kmPerAU');\n   return [\n     ach * cosphi * cosst / kmPerAU,\n     ach * cosphi * sinst / kmPerAU,\n     ash * sinphi / kmPerAU,\n"
                },
                {
                    "date": 1642997189325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -268,9 +268,9 @@\n   var ash = earthEquatorialRadiusKM * s;\n   var stlocl = radians(15.0 * st + observer.longitude);\n   var sinst = sin(stlocl);\n   var cosst = cos(stlocl);\n-  print('$ach * $cosphi * $cosst / $kmPerAU');\n+  print('$ach  $cosphi  $cosst $kmPerAU');\n   return [\n     ach * cosphi * cosst / kmPerAU,\n     ach * cosphi * sinst / kmPerAU,\n     ash * sinphi / kmPerAU,\n"
                },
                {
                    "date": 1642997392189,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -269,8 +269,9 @@\n   var stlocl = radians(15.0 * st + observer.longitude);\n   var sinst = sin(stlocl);\n   var cosst = cos(stlocl);\n   print('$ach  $cosphi  $cosst $kmPerAU');\n+  print(ach * cosphi * cosst / kmPerAU);\n   return [\n     ach * cosphi * cosst / kmPerAU,\n     ach * cosphi * sinst / kmPerAU,\n     ash * sinphi / kmPerAU,\n"
                },
                {
                    "date": 1642997631949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -213,8 +213,9 @@\n \n List geoPos(time, observer) {\n   var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n+  print(pos1);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n   return outpos;\n }\n@@ -268,10 +269,8 @@\n   var ash = earthEquatorialRadiusKM * s;\n   var stlocl = radians(15.0 * st + observer.longitude);\n   var sinst = sin(stlocl);\n   var cosst = cos(stlocl);\n-  print('$ach  $cosphi  $cosst $kmPerAU');\n-  print(ach * cosphi * cosst / kmPerAU);\n   return [\n     ach * cosphi * cosst / kmPerAU,\n     ach * cosphi * sinst / kmPerAU,\n     ash * sinphi / kmPerAU,\n"
                },
                {
                    "date": 1642997685721,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -213,10 +213,10 @@\n \n List geoPos(time, observer) {\n   var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n-  print(pos1);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n+  print(pos2);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n   return outpos;\n }\n \n"
                },
                {
                    "date": 1642997949472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -170,27 +170,27 @@\n }\n \n RotationMatrix nutationRot(time, direction) {\n   var tilt = iau2000b(time);\n-  var oblm = radians(tilt.mobl);\n-  var oblt = radians(tilt.tobl);\n-  var psi = tilt.dpsi * asec2rad;\n-  var cobm = cos(oblm);\n-  var sobm = sin(oblm);\n-  var cobt = cos(oblt);\n-  var sobt = sin(oblt);\n-  var cpsi = cos(psi);\n-  var spsi = sin(psi);\n+  double oblm = radians(tilt.mobl);\n+  double oblt = radians(tilt.tobl);\n+  double psi = tilt.dpsi * asec2rad;\n+  double cobm = cos(oblm);\n+  double sobm = sin(oblm);\n+  double cobt = cos(oblt);\n+  double sobt = sin(oblt);\n+  double cpsi = cos(psi);\n+  double spsi = sin(psi);\n \n-  var xx = cpsi;\n-  var yx = -spsi * cobm;\n-  var zx = -spsi * sobm;\n-  var xy = spsi * cobt;\n-  var yy = cpsi * cobm * cobt + sobm * sobt;\n-  var zy = cpsi * sobm * cobt - cobm * sobt;\n-  var xz = spsi * sobt;\n-  var yz = cpsi * cobm * sobt - sobm * cobt;\n-  var zz = cpsi * sobm * sobt + cobm * cobt;\n+  double xx = cpsi;\n+  double yx = -spsi * cobm;\n+  double zx = -spsi * sobm;\n+  double xy = spsi * cobt;\n+  double yy = cpsi * cobm * cobt + sobm * sobt;\n+  double zy = cpsi * sobm * cobt - cobm * sobt;\n+  double xz = spsi * sobt;\n+  double yz = cpsi * cobm * sobt - sobm * cobt;\n+  double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1642998013932,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,13 +59,8 @@\n   double sidTimeDeg = sidTime * 15; //Звездное время в градусах\n   return sidTimeDeg;\n }\n \n-// Map<int, String> test(double x) {\n-//   var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n-//   return map2;\n-// }\n-\n RotationMatrix? precessionRot(time, direction) {\n   double eps0 = 84381.406;\n   double t = time / 36525;\n \n@@ -214,10 +209,11 @@\n List geoPos(time, observer) {\n   var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n-  print(pos2);\n+  // print(pos2);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n+  print(outpos);\n   return outpos;\n }\n \n List terra(observer, st) {\n"
                },
                {
                    "date": 1642998272618,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,11 +209,9 @@\n List geoPos(time, observer) {\n   var gast = siderealTime(time);\n   var pos1 = terra(observer, gast);\n   var pos2 = nutation(pos1, time, PrecessDir.into2000);\n-  // print(pos2);\n   var outpos = precession(pos2, time, PrecessDir.into2000);\n-  print(outpos);\n   return outpos;\n }\n \n List terra(observer, st) {\n"
                },
                {
                    "date": 1642999840460,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-\n+  print(tilt.dpsi);\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n"
                },
                {
                    "date": 1642999979324,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-  print(tilt.dpsi);\n+\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n@@ -184,9 +184,9 @@\n   double zy = cpsi * sobm * cobt - cobm * sobt;\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n-\n+  print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n     return RotationMatrix([\n"
                },
                {
                    "date": 1643000167079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -184,9 +184,10 @@\n   double zy = cpsi * sobm * cobt - cobm * sobt;\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n-  print('$xx, $xy, $xz');\n+\n+  xx = print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n     return RotationMatrix([\n"
                },
                {
                    "date": 1643000216969,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,9 +185,11 @@\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n-  xx = print('$xx, $xy, $xz');\n+  xy = 0.000025113680670938138;\n+  xz = 0.000025113680670938138;\n+  print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n     return RotationMatrix([\n"
                },
                {
                    "date": 1643000232818,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,10 +186,10 @@\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   xy = 0.000025113680670938138;\n-  xz = 0.000025113680670938138;\n-  print('$xx, $xy, $xz');\n+  xz = 0.000010913210693829954;\n+  // print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n     return RotationMatrix([\n"
                },
                {
                    "date": 1643000282503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,10 +185,10 @@\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n-  xy = 0.000025113680670938138;\n-  xz = 0.000010913210693829954;\n+  xy = 0.000025163680670938138;\n+  xz = 0.000010911210693829954;\n   // print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643000294988,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,10 +185,10 @@\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n-  xy = 0.000025163680670938138;\n-  xz = 0.000010911210693829954;\n+  // xy = 0.000025163680670938138;\n+  // xz = 0.000010911210693829954;\n   // print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643000437025,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,10 +185,10 @@\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n-  // xy = 0.000025163680670938138;\n-  // xz = 0.000010911210693829954;\n+  xy = 0.000025163680670938138;\n+  xz = 0.000010911210693829954;\n   // print('$xx, $xy, $xz');\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643000819123,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,11 +185,12 @@\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n-  xy = 0.000025163680670938138;\n-  xz = 0.000010911210693829954;\n-  // print('$xx, $xy, $xz');\n+  // xy = 0.000025163680670938138;\n+  // xz = 0.000010911210693829954;\n+  print('$xx, $xy, $xz $xx, $xy, $xz $xx, $xy, $xz');\n+\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n     return RotationMatrix([\n"
                },
                {
                    "date": 1643000842591,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,9 +187,9 @@\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   // xy = 0.000025163680670938138;\n   // xz = 0.000010911210693829954;\n-  print('$xx, $xy, $xz $xx, $xy, $xz $xx, $xy, $xz');\n+  print('$xx, $xy, $xz $yx, $yy, $yz $zx, $zy, $zz');\n \n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643000946976,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -187,9 +187,11 @@\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   // xy = 0.000025163680670938138;\n   // xz = 0.000010911210693829954;\n-  print('$xx, $xy, $xz $yx, $yy, $yz $zx, $zy, $zz');\n+  print('$xx, $xy, $xz  ');\n+  print('$yx, $yy, $yz');\n+  print('$zx, $zy, $zz');\n \n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643001186056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-\n+  print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n@@ -187,11 +187,11 @@\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   // xy = 0.000025163680670938138;\n   // xz = 0.000010911210693829954;\n-  print('$xx, $xy, $xz  ');\n-  print('$yx, $yy, $yz');\n-  print('$zx, $zy, $zz');\n+  // print('$xx, $xy, $xz  ');\n+  // print('$yx, $yy, $yz');\n+  // print('$zx, $zy, $zz');\n \n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643001367790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,10 @@\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-  print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n+  // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n+  print(oblt);\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n"
                },
                {
                    "date": 1643001478710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,9 +175,9 @@\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n   // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n-  print(oblt);\n+  print(tilt.tobl);\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n"
                },
                {
                    "date": 1643001925980,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,9 +175,9 @@\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n   // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n-  print(tilt.tobl);\n+  print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n"
                },
                {
                    "date": 1643002237221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -773,8 +773,9 @@\n   deps = 0.000388 + (de * 1.0e-7);\n \n   double mobl = meanObliq(time);\n   double tobl = mobl + (deps / 3600.0);\n+  print('$mobl $tobl');\n   double tt = time;\n   double ee = dpsi * cos(radians(mobl)) / 15.0;\n \n   return Etilt(dpsi, deps, mobl, tobl, tt, ee);\n"
                },
                {
                    "date": 1643002268690,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,9 +175,9 @@\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n   // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n-  print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n+  // print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n"
                },
                {
                    "date": 1643002528254,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -164,9 +164,10 @@\n   return rotate(r, pos);\n }\n \n RotationMatrix nutationRot(time, direction) {\n-  var tilt = iau2000b(time);\n+  Etilt tilt = iau2000b(time);\n+  print('${tilt.mobl} ${tilt.tobl}');\n   double oblm = radians(tilt.mobl);\n   double oblt = radians(tilt.tobl);\n   double psi = tilt.dpsi * asec2rad;\n   double cobm = cos(oblm);\n"
                },
                {
                    "date": 1643002701248,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,9 +165,9 @@\n }\n \n RotationMatrix nutationRot(time, direction) {\n   Etilt tilt = iau2000b(time);\n-  print('${tilt.mobl} ${tilt.tobl}');\n+\n   double oblm = radians(tilt.mobl);\n   double oblt = radians(tilt.tobl);\n   double psi = tilt.dpsi * asec2rad;\n   double cobm = cos(oblm);\n@@ -176,9 +176,9 @@\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n   // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n-  // print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n+  print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n@@ -774,9 +774,8 @@\n   deps = 0.000388 + (de * 1.0e-7);\n \n   double mobl = meanObliq(time);\n   double tobl = mobl + (deps / 3600.0);\n-  print('$mobl $tobl');\n   double tt = time;\n   double ee = dpsi * cos(radians(mobl)) / 15.0;\n \n   return Etilt(dpsi, deps, mobl, tobl, tt, ee);\n"
                },
                {
                    "date": 1643002778113,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,10 +175,10 @@\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-  // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n-  print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n+  print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n+  // print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n"
                },
                {
                    "date": 1643002827006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,15 +169,16 @@\n \n   double oblm = radians(tilt.mobl);\n   double oblt = radians(tilt.tobl);\n   double psi = tilt.dpsi * asec2rad;\n+  print(psi);\n   double cobm = cos(oblm);\n   double sobm = sin(oblm);\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-  print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n+  // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n   // print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n"
                },
                {
                    "date": 1643002873411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,16 +169,15 @@\n \n   double oblm = radians(tilt.mobl);\n   double oblt = radians(tilt.tobl);\n   double psi = tilt.dpsi * asec2rad;\n-  print(psi);\n   double cobm = cos(oblm);\n   double sobm = sin(oblm);\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-  // print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n+  print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n   // print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n"
                },
                {
                    "date": 1643003005302,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,10 +175,9 @@\n   double cobt = cos(oblt);\n   double sobt = sin(oblt);\n   double cpsi = cos(psi);\n   double spsi = sin(psi);\n-  print('$oblm $oblt $psi $cobm $sobm $cobt $sobt $cpsi $spsi');\n-  // print('${tilt.tobl} ${tilt.mobl} ${tilt.deps}');\n+\n   double xx = cpsi;\n   double yx = -spsi * cobm;\n   double zx = -spsi * sobm;\n   double xy = spsi * cobt;\n@@ -189,11 +188,11 @@\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   // xy = 0.000025163680670938138;\n   // xz = 0.000010911210693829954;\n-  // print('$xx, $xy, $xz  ');\n-  // print('$yx, $yy, $yz');\n-  // print('$zx, $zy, $zz');\n+  print('$xx, $xy, $xz');\n+  print('$yx, $yy, $yz');\n+  print('$zx, $zy, $zz');\n \n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643003172168,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,11 +188,11 @@\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n   // xy = 0.000025163680670938138;\n   // xz = 0.000010911210693829954;\n-  print('$xx, $xy, $xz');\n-  print('$yx, $yy, $yz');\n-  print('$zx, $zy, $zz');\n+  // print('$xx, $xy, $xz');\n+  // print('$yx, $yy, $yz');\n+  // print('$zx, $zy, $zz'); // все совпало\n \n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n"
                },
                {
                    "date": 1643003452454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,13 +147,15 @@\n     ecl[1] * sinObl + ecl[2] * cosObl\n   ];\n }\n \n-List rotate(rot, vec) => [\n-      rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n-      rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n-      rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n-    ];\n+List rotate(rot, vec) {\n+  return [\n+    rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n+    rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n+    rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n+  ];\n+}\n \n List precession(pos, time, direction) {\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n"
                },
                {
                    "date": 1643003468204,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,8 +148,9 @@\n   ];\n }\n \n List rotate(rot, vec) {\n+  print(vec);\n   return [\n     rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n     rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n     rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n"
                },
                {
                    "date": 1643003715691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,9 +148,9 @@\n   ];\n }\n \n List rotate(rot, vec) {\n-  print(vec);\n+  print(vec[0]);\n   return [\n     rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n     rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n     rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n"
                },
                {
                    "date": 1643003886344,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,9 +148,9 @@\n   ];\n }\n \n List rotate(rot, vec) {\n-  print(vec[0]);\n+  print(vec[1]);\n   return [\n     rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n     rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n     rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n"
                },
                {
                    "date": 1643003911682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,9 +148,9 @@\n   ];\n }\n \n List rotate(rot, vec) {\n-  print(vec[1]);\n+  print(vec[2]);\n   return [\n     rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n     rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n     rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n"
                },
                {
                    "date": 1643003942332,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -148,9 +148,9 @@\n   ];\n }\n \n List rotate(rot, vec) {\n-  print(vec[2]);\n+  // print(vec[2]);\n   return [\n     rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n     rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n     rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n"
                },
                {
                    "date": 1643004734533,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -147,16 +147,13 @@\n     ecl[1] * sinObl + ecl[2] * cosObl\n   ];\n }\n \n-List rotate(rot, vec) {\n-  // print(vec[2]);\n-  return [\n-    rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n-    rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n-    rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n-  ];\n-}\n+List rotate(rot, vec) => [\n+      rot.rot[0][0] * vec[0] + rot.rot[1][0] * vec[1] + rot.rot[2][0] * vec[2],\n+      rot.rot[0][1] * vec[0] + rot.rot[1][1] * vec[1] + rot.rot[2][1] * vec[2],\n+      rot.rot[0][2] * vec[0] + rot.rot[1][2] * vec[1] + rot.rot[2][2] * vec[2]\n+    ];\n \n List precession(pos, time, direction) {\n   var r = precessionRot(time, direction);\n   return rotate(r, pos);\n@@ -189,14 +186,8 @@\n   double xz = spsi * sobt;\n   double yz = cpsi * cobm * sobt - sobm * cobt;\n   double zz = cpsi * sobm * sobt + cobm * cobt;\n \n-  // xy = 0.000025163680670938138;\n-  // xz = 0.000010911210693829954;\n-  // print('$xx, $xy, $xz');\n-  // print('$yx, $yy, $yz');\n-  // print('$zx, $zy, $zz'); // все совпало\n-\n   if (direction == PrecessDir.from2000)\n   // convert J2000 to of-date\n   {\n     return RotationMatrix([\n@@ -239,29 +230,11 @@\n   return theta;\n }\n \n Vector vector2radec(pos, time) {\n-  double ra, dec;\n-  var xyproj = pos[0] * pos[0] + pos[1] * pos[1];\n-  var dist = sqrt(xyproj + pos[2] * pos[2]);\n-  if (xyproj == 0.0) {\n-    ra = 0.0;\n-    if (pos[2] < 0.0) {\n-      dec = -90.0;\n-    } else {\n-      dec = 90.0;\n-    }\n-  } else {\n-    ra = rad2hour * atan2(pos[1], pos[0]);\n-\n-    if (ra < 0) {\n-      ra += 24;\n-    }\n-    dec = degrees(atan2(pos[2], sqrt(xyproj)));\n-  }\n   Vector vec = Vector(pos[0], pos[1], pos[2], time);\n   return vec;\n-} //Equatorial(ra, dec, dist, vec)\n+}\n \n List terraPosvel(observer, st) {\n   var df2 = earthFlattening * earthFlattening;\n   var phi = radians(observer.latitude);\n@@ -781,4 +754,29 @@\n   double ee = dpsi * cos(radians(mobl)) / 15.0;\n \n   return Etilt(dpsi, deps, mobl, tobl, tt, ee);\n }\n+\n+\n+\n+// Vector vector2radec(pos, time) {\n+//   double ra, dec;\n+//   var xyproj = pos[0] * pos[0] + pos[1] * pos[1];\n+//   var dist = sqrt(xyproj + pos[2] * pos[2]);\n+//   if (xyproj == 0.0) {\n+//     ra = 0.0;\n+//     if (pos[2] < 0.0) {\n+//       dec = -90.0;\n+//     } else {\n+//       dec = 90.0;\n+//     }\n+//   } else {\n+//     ra = rad2hour * atan2(pos[1], pos[0]);\n+\n+//     if (ra < 0) {\n+//       ra += 24;\n+//     }\n+//     dec = degrees(atan2(pos[2], sqrt(xyproj)));\n+//   }\n+//   Vector vec = Vector(pos[0], pos[1], pos[2], time);\n+//   return vec;\n+// }\n"
                },
                {
                    "date": 1643005586182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,15 +249,16 @@\n   var cosst = cos(stlocl);\n   return [\n     ach * cosphi * cosst / kmPerAU,\n     ach * cosphi * sinst / kmPerAU,\n-    ash * sinphi / kmPerAU,\n-    -angvel * ach * cosphi * sinst * 86400 / kmPerAU,\n-    angvel * ach * cosphi * cosst * 86400 / kmPerAU,\n-    0.0\n+    ash * sinphi / kmPerAU\n   ];\n }\n \n+//,\n+// -angvel * ach * cosphi * sinst * 86400 / kmPerAU,\n+// angvel * ach * cosphi * cosst * 86400 / kmPerAU,\n+// 0.0\n double siderealTime(time) {\n   var t = time / 36525.0;\n   var theta = era(time);\n   var st = (0.014506 +\n"
                },
                {
                    "date": 1643005652827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -253,12 +253,8 @@\n     ash * sinphi / kmPerAU\n   ];\n }\n \n-//,\n-// -angvel * ach * cosphi * sinst * 86400 / kmPerAU,\n-// angvel * ach * cosphi * cosst * 86400 / kmPerAU,\n-// 0.0\n double siderealTime(time) {\n   var t = time / 36525.0;\n   var theta = era(time);\n   var st = (0.014506 +\n"
                }
            ],
            "date": 1642125034994,
            "name": "Commit-0",
            "content": "import 'dart:math';\n\ndouble radians(double rad) => rad * pi / 180;\ndouble degrees(double grad) => grad / pi * 180;\n\n//Приведение к 360 градусов\ndouble deg_360(double x) {\n  var rv = x - (x / 360.0).truncate() * 360.0;\n  if (rv < 0.0) {\n    rv += 360.0;\n  }\n  return rv;\n}\n\ndouble time_24(double t0) {\n  var t = t0 - (t0 / 24.0).truncate() * 24.0;\n  if (t < 0.0) {\n    t += 24.0;\n  }\n  return t;\n}\n\n//конвертируем RA -> время, 15град=1час\nList<int> timeRA(double ra) {\n  var hRA = (ra ~/ 15).toInt();\n  var mRA = ((ra / 15 - hRA) * 60 ~/ 1).toInt();\n  var sRA = ((ra / 15 - hRA) * 60 % 1 * 60).toInt();\n  return [hRA, mRA, sRA];\n}\n\ndouble numDate(int y, int m, int D, int hour, int minute) {\n  int _d = (367 * y -\n          7 * (y + ((m + 9) / 12)).toInt() ~/ 4 -\n          3 * ((y + ((m - 9) / 7)).toInt() / 100 + 1) / 4 +\n          275 * m ~/ 9 +\n          D -\n          730515)\n      .toInt();\n  double ut = hour + (minute / 60);\n  double d = _d + ut / 24;\n  return d;\n}\n\ndouble localSidTime(int hour, int minute, L, lon) {\n  double ut = hour + (minute / 60);\n  double gmst0 = time_24(L / 15 + 12); // L солнечная долгота\n  double sidTime = gmst0 + ut + lon / 15;\n  double sidTimeDeg = sidTime * 15; //Звездное время в градусах\n  return sidTimeDeg;\n}\n\nMap<int, String> test(double x) {\n  var map2 = {x.toInt(): \"Tom\", 2: \"Bob\", 3: \"Sam\"};\n  return map2;\n}\n\n// def precession_rot(time, direction):\n//     eps0 = 84381.406\n//     t = time.tt / 36525\n\n//     psia = (((((- 0.0000000951 * t\n//                 + 0.000132851) * t\n//                - 0.00114045) * t\n//               - 1.0790069) * t\n//              + 5038.481507) * t)\n\n//     omegaa = (((((+ 0.0000003337 * t\n//                  - 0.000000467) * t\n//                  - 0.00772503) * t\n//                 + 0.0512623) * t\n//                - 0.025754) * t + eps0)\n\n//     chia = (((((- 0.0000000560 * t\n//                 + 0.000170663) * t\n//                - 0.00121197) * t\n//               - 2.3814292) * t\n//              + 10.556403) * t)\n\n//     eps0 *= ASEC2RAD\n//     psia *= ASEC2RAD\n//     omegaa *= ASEC2RAD\n//     chia *= ASEC2RAD\n\n//     sa = sin(eps0)\n//     ca = cos(eps0)\n//     sb = sin(-psia)\n//     cb = cos(-psia)\n//     sc = sin(-omegaa)\n//     cc = cos(-omegaa)\n//     sd = sin(chia)\n//     cd = cos(chia)\n\n//     xx = cd * cb - sb * sd * cc\n//     yx = cd * sb * ca + sd * cc * cb * ca - sa * sd * sc\n//     zx = cd * sb * sa + sd * cc * cb * sa + ca * sd * sc\n//     xy = -sd * cb - sb * cd * cc\n//     yy = -sd * sb * ca + cd * cc * cb * ca - sa * cd * sc\n//     zy = -sd * sb * sa + cd * cc * cb * sa + ca * cd * sc\n//     xz = sb * sc\n//     yz = -sc * cb * ca - sa * cc\n//     zz = -sc * cb * sa + cc * ca\n//     if direction == PrecessDir.Into2000:\n//         # Perform rotation from other epoch to J2000.0.\n//         return RotationMatrix([\n//             [xx, yx, zx],\n//             [xy, yy, zy],\n//             [xz, yz, zz]\n//         ])\n\n//     if direction == PrecessDir.From2000:\n//         # Perform rotation from J2000.0 to other epoch.\n//         return RotationMatrix([\n//             [xx, xy, xz],\n//             [yx, yy, yz],\n//             [zx, zy, zz]\n//         ])\n\n//     raise Error('Inalid precession direction')\n\n// def mean_obliq(tt):\n//     t = tt / 36525\n//     asec = (\n//         ((((- 0.0000000434 * t\n//             - 0.000000576) * t\n//            + 0.00200340) * t\n//           - 0.0001831) * t\n//          - 46.836769) * t + 84381.406\n//     )\n//     return asec / 3600.0\n\n// def ecl2equ_vec(time, ecl):\n//     obl = radians(mean_obliq(time.tt))\n//     cos_obl = cos(obl)\n//     sin_obl = sin(obl)\n//     return [\n//         ecl[0],\n//         ecl[1]*cos_obl - ecl[2]*sin_obl,\n//         ecl[1]*sin_obl + ecl[2]*cos_obl\n//     ]\n\n// def rotate(rot, vec):\n//     return [\n//         rot.rot[0][0]*vec[0] + rot.rot[1][0]*vec[1] + rot.rot[2][0]*vec[2],\n//         rot.rot[0][1]*vec[0] + rot.rot[1][1]*vec[1] + rot.rot[2][1]*vec[2],\n//         rot.rot[0][2]*vec[0] + rot.rot[1][2]*vec[1] + rot.rot[2][2]*vec[2]\n//     ]\n\n// def precession(pos, time, direction):\n//     r = precession_rot(time, direction)\n//     return rotate(r, pos)\n\n// # -------------------------\n// # 1. Парсинг входной даты\n// # -------------------------\n\n// # def ParseArgs(args):\n// #     if len(args) not in [3, 4]:\n// #         print(\n// #             'USAGE: {} latitude longitude [yyyy-mm-ddThh:mm:ssZ]'.format(args[0]))\n// #         sys.exit(1)\n// #     latitude = float(args[1])\n// #     longitude = float(args[2])\n// #     if len(args) == 4:\n// #         time = Time.Parse(args[3])\n// #     else:\n// #         time = Time.Now()\n// #     observer = Observer(latitude, longitude)\n// #     return (observer, time)\n"
        }
    ]
}