{
    "sourceFile": "bin/vsop/src/complex_new.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1642656405120,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1642656650742,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,17 +4,17 @@\n // ignore_for_file: unnecessary_getters_setters, hash_and_equals\n \n import 'dart:math';\n \n-class Complex {\n+class ComplexN {\n   num _real;\n   num _imag;\n \n   // 1- Here we define different ways to build a complex number:\n   // constructors:\n-  Complex([this._real = 0, this._imag = 0]);\n-  Complex.im(num imaginary) : this(0, imaginary);\n-  Complex.re(num real) : this(real, 0);\n+  ComplexN([this._real = 0, this._imag = 0]);\n+  ComplexN.im(num imaginary) : this(0, imaginary);\n+  ComplexN.re(num real) : this(real, 0);\n   // 2- The normal utility methods to get and set the real and\n   // imaginary part, to get the absolute value and the angle, to\n   //  compare two complex numbers:\n   num get real => _real;\n@@ -25,9 +25,9 @@\n   num get angle => atan2(imaginary, real);\n \n   @override\n   bool operator ==(other) {\n-    if (other is! Complex) {\n+    if (other is! ComplexN) {\n       return false;\n     }\n     return real == other.real && imaginary == other.imaginary;\n   }\n@@ -56,71 +56,71 @@\n \n   // 3- operator overloading:\n   // The basic operations for adding, multiplying, subtraction and    //\n   //  division are defined as overloading of the operators +, *, - and /\n-  Complex operator +(Complex x) {\n-    return Complex(_real + x.real, _imag + x.imaginary);\n+  ComplexN operator +(ComplexN x) {\n+    return ComplexN(_real + x.real, _imag + x.imaginary);\n   }\n \n-  Complex operator -(var x) {\n-    if (x is Complex) {\n-      return Complex(real - x.real, imaginary - x.imaginary);\n+  ComplexN operator -(var x) {\n+    if (x is ComplexN) {\n+      return ComplexN(real - x.real, imaginary - x.imaginary);\n     } else if (x is num) {\n       _real -= x;\n       return this;\n     }\n     throw 'Not a number';\n   }\n \n-  Complex operator *(var x) {\n-    if (x is Complex) {\n+  ComplexN operator *(var x) {\n+    if (x is ComplexN) {\n       num realAux = (real * x.real - imaginary * x.imaginary);\n       num imagAux = (imaginary * x.real + real * x.imaginary);\n-      return Complex(realAux, imagAux);\n+      return ComplexN(realAux, imagAux);\n     } else if (x is num) {\n-      return Complex(real * x, imaginary * x);\n+      return ComplexN(real * x, imaginary * x);\n     }\n     throw 'Not a number';\n   }\n \n-  Complex operator /(var x) {\n-    if (x is Complex) {\n+  ComplexN operator /(var x) {\n+    if (x is ComplexN) {\n       num realAux = (real * x.real + imaginary * x.imaginary) /\n           (x.real * x.real + x.imaginary * x.imaginary);\n       num imagAux = (imaginary * x.real - real * x.imaginary) /\n           (x.real * x.real + x.imaginary * x.imaginary);\n-      return Complex(realAux, imagAux);\n+      return ComplexN(realAux, imagAux);\n     } else if (x is num) {\n-      return Complex(real / x, imaginary / x);\n+      return ComplexN(real / x, imaginary / x);\n     }\n     throw 'Not a number';\n   }\n \n   // 4- Here we define the same operations as methods:\n-  static Complex add(Complex c1, Complex c2) {\n+  static ComplexN add(ComplexN c1, ComplexN c2) {\n     num rr = c1.real + c2.real;\n     num ii = c1.imaginary + c2.imaginary;\n-    return Complex(rr, ii);\n+    return ComplexN(rr, ii);\n   }\n \n-  static Complex subtract(Complex c1, Complex c2) {\n+  static ComplexN subtract(ComplexN c1, ComplexN c2) {\n     num rr = c1.real - c2.real;\n     num ii = c1.imaginary - c2.imaginary;\n-    return Complex(rr, ii);\n+    return ComplexN(rr, ii);\n   }\n \n-  static Complex multiply(Complex c1, Complex c2) {\n+  static ComplexN multiply(ComplexN c1, ComplexN c2) {\n     num rr = c1.real * c2.real - c1.imaginary * c2.imaginary;\n     num ii = c1.real * c2.imaginary + c1.imaginary * c2.real;\n-    return Complex(rr, ii);\n+    return ComplexN(rr, ii);\n   }\n \n-  static Complex divide(Complex c1, Complex c2) {\n+  static ComplexN divide(ComplexN c1, ComplexN c2) {\n     num real = (c1.real * c2.real + c1.imaginary * c2.imaginary) /\n         (c2.real * c2.real + c2.imaginary * c2.imaginary);\n     num imag = (c1.imaginary * c2.real - c1.real * c2.imaginary) /\n         (c2.real * c2.real + c2.imaginary * c2.imaginary);\n-    return Complex(real, imag);\n+    return ComplexN(real, imag);\n   }\n \n   // static Complex conjugate(var c1, Complex c2) {\n   //   var rr = exp(c1) * cos(c2.real) + exp(c1) * sin(c2.real);\n"
                }
            ],
            "date": 1642656405120,
            "name": "Commit-0",
            "content": "// ------\n// Ready\n// ------\n// ignore_for_file: unnecessary_getters_setters, hash_and_equals\n\nimport 'dart:math';\n\nclass Complex {\n  num _real;\n  num _imag;\n\n  // 1- Here we define different ways to build a complex number:\n  // constructors:\n  Complex([this._real = 0, this._imag = 0]);\n  Complex.im(num imaginary) : this(0, imaginary);\n  Complex.re(num real) : this(real, 0);\n  // 2- The normal utility methods to get and set the real and\n  // imaginary part, to get the absolute value and the angle, to\n  //  compare two complex numbers:\n  num get real => _real;\n  set real(num value) => _real = value;\n  num get imaginary => _imag;\n  set imaginary(num value) => _imag = value;\n  num get abs => sqrt(real * real + imaginary * imaginary);\n  num get angle => atan2(imaginary, real);\n\n  @override\n  bool operator ==(other) {\n    if (other is! Complex) {\n      return false;\n    }\n    return real == other.real && imaginary == other.imaginary;\n  }\n\n  // @override\n  // String toString() {\n  //   if (_imag >= 0) {\n  //     return '$_real + ${_imag}j';\n  //   }\n  //   return '$_real - ${_imag.abs()}j';\n  // }\n\n  @override\n  String toString() {\n    if (_imag >= 0) {\n      return '$_imag - ${_real}j';\n    }\n    return '$_imag + ${_real.abs()}j';\n  }\n  // static Complex conjugate(_real, _imag) {\n  //  if (_imag >= 0) {\n  //     return '$_real + ${_imag}j';\n  //   }\n  //   return '$_real - ${_imag.abs()}j';\n  // }\n\n  // 3- operator overloading:\n  // The basic operations for adding, multiplying, subtraction and    //\n  //  division are defined as overloading of the operators +, *, - and /\n  Complex operator +(Complex x) {\n    return Complex(_real + x.real, _imag + x.imaginary);\n  }\n\n  Complex operator -(var x) {\n    if (x is Complex) {\n      return Complex(real - x.real, imaginary - x.imaginary);\n    } else if (x is num) {\n      _real -= x;\n      return this;\n    }\n    throw 'Not a number';\n  }\n\n  Complex operator *(var x) {\n    if (x is Complex) {\n      num realAux = (real * x.real - imaginary * x.imaginary);\n      num imagAux = (imaginary * x.real + real * x.imaginary);\n      return Complex(realAux, imagAux);\n    } else if (x is num) {\n      return Complex(real * x, imaginary * x);\n    }\n    throw 'Not a number';\n  }\n\n  Complex operator /(var x) {\n    if (x is Complex) {\n      num realAux = (real * x.real + imaginary * x.imaginary) /\n          (x.real * x.real + x.imaginary * x.imaginary);\n      num imagAux = (imaginary * x.real - real * x.imaginary) /\n          (x.real * x.real + x.imaginary * x.imaginary);\n      return Complex(realAux, imagAux);\n    } else if (x is num) {\n      return Complex(real / x, imaginary / x);\n    }\n    throw 'Not a number';\n  }\n\n  // 4- Here we define the same operations as methods:\n  static Complex add(Complex c1, Complex c2) {\n    num rr = c1.real + c2.real;\n    num ii = c1.imaginary + c2.imaginary;\n    return Complex(rr, ii);\n  }\n\n  static Complex subtract(Complex c1, Complex c2) {\n    num rr = c1.real - c2.real;\n    num ii = c1.imaginary - c2.imaginary;\n    return Complex(rr, ii);\n  }\n\n  static Complex multiply(Complex c1, Complex c2) {\n    num rr = c1.real * c2.real - c1.imaginary * c2.imaginary;\n    num ii = c1.real * c2.imaginary + c1.imaginary * c2.real;\n    return Complex(rr, ii);\n  }\n\n  static Complex divide(Complex c1, Complex c2) {\n    num real = (c1.real * c2.real + c1.imaginary * c2.imaginary) /\n        (c2.real * c2.real + c2.imaginary * c2.imaginary);\n    num imag = (c1.imaginary * c2.real - c1.real * c2.imaginary) /\n        (c2.real * c2.real + c2.imaginary * c2.imaginary);\n    return Complex(real, imag);\n  }\n\n  // static Complex conjugate(var c1, Complex c2) {\n  //   var rr = exp(c1) * cos(c2.real) + exp(c1) * sin(c2.real);\n  //   num ii = c1.imaginary - c2.imaginary;\n  //   return Complex(rr, ii);\n  // }\n\n  /// Compute the [exponential function](http://mathworld.wolfram.com/ExponentialFunction.html)\n  /// of this complex number.\n  ///\n  /// Implements the formula:\n  ///\n  ///     exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i\n  ///\n  /// where the (real) functions on the right-hand side are\n  /// [math.exp], [math.cos], and [math.sin].\n  ///\n  /// Returns [nan] if either real or imaginary part of the\n  /// input argument is `NaN`.\n  ///\n  /// Infinite values in real or imaginary parts of the input may result in\n  /// infinite or `NaN` values returned in parts of the result.\n  ///\n  /// Examples:\n  ///\n  ///     exp(1 ± INFINITY i) = NaN + NaN i\n  ///     exp(INFINITY + i) = INFINITY + INFINITY i\n  ///     exp(-INFINITY + i) = 0 + 0i\n  ///     exp(±INFINITY ± INFINITY i) = NaN + NaN i\n}\n"
        }
    ]
}