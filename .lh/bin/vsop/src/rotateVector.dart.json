{
    "sourceFile": "bin/vsop/src/rotateVector.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 13,
            "patches": [
                {
                    "date": 1642126675758,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1642134183053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,35 +1,42 @@\n // # -------------------------\n // # Преобразование координат\n // # -------------------------\n-// from math import degrees,cos, sin, atan2, sqrt\n-// from vsop.src.classes import Vector, EclipticCoordinates, TerseVector\n+import 'dart:math';\n+import 'classes.dart';\n+import 'func.dart';\n \n+dynamic Ecliptic(equ, time) {\n+  //Преобразование прямоугольных в эклиптические координаты.\n+  //Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n+  double ob2000 =\n+      0.40909260059599012; // mean obliquity of the J2000 ecliptic in radians\n+  return RotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t);\n+}\n \n-// def Ecliptic(equ, time):\n-//     \"\"\"Преобразование прямоугольных в эклиптические координаты.\"\"\"\n-//     # Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n-//     ob2000 = 0.40909260059599012   # mean obliquity of the J2000 ecliptic in radians\n-//     return _RotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t)\n+EclipticCoordinates RotateEquatorialToEcliptic(pos, obliq_radians, time) {\n+  double cos_ob = cos(obliq_radians);\n+  double sin_ob = sin(obliq_radians);\n+  var ex = pos[0];\n+  var ey = pos[1] * cos_ob + pos[2] * sin_ob;\n+  var ez = pos[1] * sin_ob + pos[2] * cos_ob;\n+  double elon = 0;\n \n-// def _RotateEquatorialToEcliptic(pos, obliq_radians, time):\n+  double xyproj = sqrt(ex * ex + ey * ey);\n+  if (xyproj > 0.0) {\n+    double elon = degrees(atan2(ey, ex));\n+    if (elon < 0.0) {\n+      elon += 360.0;\n+    }\n+  } else {\n+    double elon = 0.0;\n+  }\n \n-//     cos_ob = cos(obliq_radians)\n-//     sin_ob = sin(obliq_radians)\n-//     ex = +pos[0]\n-//     ey = +pos[1]*cos_ob + pos[2]*sin_ob\n-//     ez = -pos[1]*sin_ob + pos[2]*cos_ob\n+  double elat = degrees(atan2(ez, xyproj));\n+  var vec = Vector(ex, ey, ez, time);\n \n-//     xyproj = sqrt(ex*ex + ey*ey)\n-//     if xyproj > 0.0:\n-//         elon = degrees(atan2(ey, ex))\n-//         if elon < 0.0:\n-//             elon += 360.0\n-//     else:\n-//         elon = 0.0\n-//     elat = degrees(atan2(ez, xyproj))\n-//     vec = Vector(ex, ey, ez, time)\n-//     return EclipticCoordinates(vec, elat, elon)\n+  return EclipticCoordinates(vec, elat, elon);\n+}\n \n // def VsopRotate(eclip):\n //     # Convert ecliptic cartesian coordinates to equatorial cartesian coordinates.\n //     x = eclip.x + 0.000000440360*eclip.y - 0.000000190919*eclip.z\n"
                },
                {
                    "date": 1642134306979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,20 +36,19 @@\n \n   return EclipticCoordinates(vec, elat, elon);\n }\n \n-// def VsopRotate(eclip):\n-//     # Convert ecliptic cartesian coordinates to equatorial cartesian coordinates.\n-//     x = eclip.x + 0.000000440360*eclip.y - 0.000000190919*eclip.z\n-//     y = -0.000000479966*eclip.x + 0.917482137087*eclip.y - 0.397776982902*eclip.z\n-//     z = 0.397776982902*eclip.y + 0.917482137087*eclip.z\n-//     return TerseVector(x, y, z)\n+TerseVector VsopRotate(eclip) {\n+  // Convert ecliptic cartesian coordinates to equatorial cartesian coordinates.\n+  double x = eclip.x + 0.000000440360 * eclip.y - 0.000000190919 * eclip.z;\n+  double y = -0.000000479966 * eclip.x +\n+      0.917482137087 * eclip.y -\n+      0.397776982902 * eclip.z;\n+  double z = 0.397776982902 * eclip.y + 0.917482137087 * eclip.z;\n+  return TerseVector(x, y, z);\n+}\n \n\\ No newline at end of file\n-\n-// def VsopSphereToRect(lon, lat, rad):\n-//     # Convert spherical coordinates to cartesian coordinates.\n-//     r_coslat = rad * cos(lat)\n-//     return TerseVector(\n-//         r_coslat * cos(lon),\n-//         r_coslat * sin(lon),\n-//         rad * sin(lat)\n-//     )\n+TerseVector VsopSphereToRect(lon, lat, rad) {\n+  // Convert spherical coordinates to cartesian coordinates.\n+  double r_coslat = rad * cos(lat);\n+  return TerseVector(r_coslat * cos(lon), r_coslat * sin(lon), rad * sin(lat));\n+}\n"
                },
                {
                    "date": 1642134347560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,7 @@\n+// ------\n+// Ready\n+// ------\n // # -------------------------\n // # Преобразование координат\n // # -------------------------\n import 'dart:math';\n@@ -50,5 +53,5 @@\n TerseVector VsopSphereToRect(lon, lat, rad) {\n   // Convert spherical coordinates to cartesian coordinates.\n   double r_coslat = rad * cos(lat);\n   return TerseVector(r_coslat * cos(lon), r_coslat * sin(lon), rad * sin(lat));\n-}\n\\ No newline at end of file\n+}\n"
                },
                {
                    "date": 1642398342869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,41 +7,41 @@\n import 'dart:math';\n import 'classes.dart';\n import 'func.dart';\n \n-dynamic Ecliptic(equ, time) {\n+dynamic ecliptic(equ, time) {\n   //Преобразование прямоугольных в эклиптические координаты.\n   //Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n   double ob2000 =\n       0.40909260059599012; // mean obliquity of the J2000 ecliptic in radians\n-  return RotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t);\n+  return rotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t);\n }\n \n-EclipticCoordinates RotateEquatorialToEcliptic(pos, obliq_radians, time) {\n-  double cos_ob = cos(obliq_radians);\n-  double sin_ob = sin(obliq_radians);\n+EclipticCoordinates rotateEquatorialToEcliptic(pos, obliqRadians, time) {\n+  double cosOb = cos(obliqRadians);\n+  double sinOb = sin(obliqRadians);\n   var ex = pos[0];\n-  var ey = pos[1] * cos_ob + pos[2] * sin_ob;\n-  var ez = pos[1] * sin_ob + pos[2] * cos_ob;\n+  var ey = pos[1] * cosOb + pos[2] * sinOb;\n+  var ez = pos[1] * sinOb + pos[2] * cosOb;\n   double elon = 0;\n \n   double xyproj = sqrt(ex * ex + ey * ey);\n   if (xyproj > 0.0) {\n-    double elon = degrees(atan2(ey, ex));\n+    elon = degrees(atan2(ey, ex));\n     if (elon < 0.0) {\n       elon += 360.0;\n     }\n   } else {\n-    double elon = 0.0;\n+    elon = 0.0;\n   }\n \n   double elat = degrees(atan2(ez, xyproj));\n   var vec = Vector(ex, ey, ez, time);\n \n   return EclipticCoordinates(vec, elat, elon);\n }\n \n-TerseVector VsopRotate(eclip) {\n+TerseVector vsopRotate(eclip) {\n   // Convert ecliptic cartesian coordinates to equatorial cartesian coordinates.\n   double x = eclip.x + 0.000000440360 * eclip.y - 0.000000190919 * eclip.z;\n   double y = -0.000000479966 * eclip.x +\n       0.917482137087 * eclip.y -\n@@ -49,9 +49,9 @@\n   double z = 0.397776982902 * eclip.y + 0.917482137087 * eclip.z;\n   return TerseVector(x, y, z);\n }\n \n-TerseVector VsopSphereToRect(lon, lat, rad) {\n+TerseVector vsopSphereToRect(lon, lat, rad) {\n   // Convert spherical coordinates to cartesian coordinates.\n-  double r_coslat = rad * cos(lat);\n-  return TerseVector(r_coslat * cos(lon), r_coslat * sin(lon), rad * sin(lat));\n+  double rCosLat = rad * cos(lat);\n+  return TerseVector(rCosLat * cos(lon), rCosLat * sin(lon), rad * sin(lat));\n }\n"
                },
                {
                    "date": 1642398378040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n import 'dart:math';\n import 'classes.dart';\n import 'func.dart';\n \n-dynamic ecliptic(equ, time) {\n+EclipticCoordinates ecliptic(equ, time) {\n   //Преобразование прямоугольных в эклиптические координаты.\n   //Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n   double ob2000 =\n       0.40909260059599012; // mean obliquity of the J2000 ecliptic in radians\n"
                },
                {
                    "date": 1642569502685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n   double sinOb = sin(obliqRadians);\n   var ex = pos[0];\n   var ey = pos[1] * cosOb + pos[2] * sinOb;\n   var ez = pos[1] * sinOb + pos[2] * cosOb;\n-  double elon = 0;\n+  double elon;\n \n   double xyproj = sqrt(ex * ex + ey * ey);\n   if (xyproj > 0.0) {\n     elon = degrees(atan2(ey, ex));\n"
                },
                {
                    "date": 1642569520156,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n   var ex = pos[0];\n   var ey = pos[1] * cosOb + pos[2] * sinOb;\n   var ez = pos[1] * sinOb + pos[2] * cosOb;\n   double elon;\n-\n+  print(ez);\n   double xyproj = sqrt(ex * ex + ey * ey);\n   if (xyproj > 0.0) {\n     elon = degrees(atan2(ey, ex));\n     if (elon < 0.0) {\n"
                },
                {
                    "date": 1642569565679,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n   var ex = pos[0];\n   var ey = pos[1] * cosOb + pos[2] * sinOb;\n   var ez = pos[1] * sinOb + pos[2] * cosOb;\n   double elon;\n-  print(ez);\n+  print(pos[0]);\n   double xyproj = sqrt(ex * ex + ey * ey);\n   if (xyproj > 0.0) {\n     elon = degrees(atan2(ey, ex));\n     if (elon < 0.0) {\n"
                },
                {
                    "date": 1642569679499,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n   var ex = pos[0];\n   var ey = pos[1] * cosOb + pos[2] * sinOb;\n   var ez = pos[1] * sinOb + pos[2] * cosOb;\n   double elon;\n-  print(pos[0]);\n+  // print(pos[0]);\n   double xyproj = sqrt(ex * ex + ey * ey);\n   if (xyproj > 0.0) {\n     elon = degrees(atan2(ey, ex));\n     if (elon < 0.0) {\n"
                },
                {
                    "date": 1642577182316,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   //Преобразование прямоугольных в эклиптические координаты.\n   //Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n   double ob2000 =\n       0.40909260059599012; // mean obliquity of the J2000 ecliptic in radians\n-  return rotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t);\n+  return rotateEquatorialToEcliptic([equ!.x, equ.y, equ.z], ob2000, equ.t);\n }\n \n EclipticCoordinates rotateEquatorialToEcliptic(pos, obliqRadians, time) {\n   double cosOb = cos(obliqRadians);\n"
                },
                {
                    "date": 1642577246352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   //Преобразование прямоугольных в эклиптические координаты.\n   //Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n   double ob2000 =\n       0.40909260059599012; // mean obliquity of the J2000 ecliptic in radians\n-  return rotateEquatorialToEcliptic([equ!.x, equ.y, equ.z], ob2000, equ.t);\n+  return rotateEquatorialToEcliptic([equ.x!, equ.y, equ.z], ob2000, equ.t);\n }\n \n EclipticCoordinates rotateEquatorialToEcliptic(pos, obliqRadians, time) {\n   double cosOb = cos(obliqRadians);\n"
                },
                {
                    "date": 1642577263104,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n   //Преобразование прямоугольных в эклиптические координаты.\n   //Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n   double ob2000 =\n       0.40909260059599012; // mean obliquity of the J2000 ecliptic in radians\n-  return rotateEquatorialToEcliptic([equ.x!, equ.y, equ.z], ob2000, equ.t);\n+  return rotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t);\n }\n \n EclipticCoordinates rotateEquatorialToEcliptic(pos, obliqRadians, time) {\n   double cosOb = cos(obliqRadians);\n"
                },
                {
                    "date": 1642608609570,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,4 @@\n-// ------\n-// Ready\n-// ------\n // # -------------------------\n // # Преобразование координат\n // # -------------------------\n import 'dart:math';\n"
                }
            ],
            "date": 1642126675758,
            "name": "Commit-0",
            "content": "// # -------------------------\n// # Преобразование координат\n// # -------------------------\n// from math import degrees,cos, sin, atan2, sqrt\n// from vsop.src.classes import Vector, EclipticCoordinates, TerseVector\n\n\n// def Ecliptic(equ, time):\n//     \"\"\"Преобразование прямоугольных в эклиптические координаты.\"\"\"\n//     # Based on NOVAS functions equ2ecl() and equ2ecl_vec().\n//     ob2000 = 0.40909260059599012   # mean obliquity of the J2000 ecliptic in radians\n//     return _RotateEquatorialToEcliptic([equ.x, equ.y, equ.z], ob2000, equ.t)\n\n// def _RotateEquatorialToEcliptic(pos, obliq_radians, time):\n\n//     cos_ob = cos(obliq_radians)\n//     sin_ob = sin(obliq_radians)\n//     ex = +pos[0]\n//     ey = +pos[1]*cos_ob + pos[2]*sin_ob\n//     ez = -pos[1]*sin_ob + pos[2]*cos_ob\n\n//     xyproj = sqrt(ex*ex + ey*ey)\n//     if xyproj > 0.0:\n//         elon = degrees(atan2(ey, ex))\n//         if elon < 0.0:\n//             elon += 360.0\n//     else:\n//         elon = 0.0\n//     elat = degrees(atan2(ez, xyproj))\n//     vec = Vector(ex, ey, ez, time)\n//     return EclipticCoordinates(vec, elat, elon)\n\n// def VsopRotate(eclip):\n//     # Convert ecliptic cartesian coordinates to equatorial cartesian coordinates.\n//     x = eclip.x + 0.000000440360*eclip.y - 0.000000190919*eclip.z\n//     y = -0.000000479966*eclip.x + 0.917482137087*eclip.y - 0.397776982902*eclip.z\n//     z = 0.397776982902*eclip.y + 0.917482137087*eclip.z\n//     return TerseVector(x, y, z)\n\n\n// def VsopSphereToRect(lon, lat, rad):\n//     # Convert spherical coordinates to cartesian coordinates.\n//     r_coslat = rad * cos(lat)\n//     return TerseVector(\n//         r_coslat * cos(lon),\n//         r_coslat * sin(lon),\n//         rad * sin(lat)\n//     )"
        }
    ]
}