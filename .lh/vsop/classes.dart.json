{
    "sourceFile": "vsop/classes.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1641795618981,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1641797091970,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -20,19 +20,19 @@\n   set imag(num value) => _imag = value;\n   num get abs => math.sqrt(real * real + imag * imag);\n   num get angle => math.atan2(imag, real);\n   bool operator ==(other) {\n-    if (!(other is Complex)) {\n+    if (other is! Complex) {\n       return false;\n     }\n-    return this.real == other.real && this.imag == other.imag;\n+    return real == other.real && imag == other.imag;\n   }\n \n   String toString() {\n     if (_imag >= 0) {\n-      return '${_real} + ${_imag}i';\n+      return '$_real + ${_imag}i';\n     }\n-    return '${_real} - ${_imag.abs()}i';\n+    return '$_real - ${_imag.abs()}i';\n   }\n \n   // 3- operator overloading:\n   // The basic operations for adding, multiplying, subtraction and    //\n@@ -42,9 +42,9 @@\n   }\n \n   Complex operator -(var x) {\n     if (x is Complex) {\n-      return Complex(this.real - x.real, this.imag - x.imag);\n+      return Complex(real - x.real, imag - x.imag);\n     } else if (x is num) {\n       _real -= x;\n       return this;\n     }\n@@ -52,26 +52,26 @@\n   }\n \n   Complex operator *(var x) {\n     if (x is Complex) {\n-      num realAux = (this.real * x.real - this.imag * x.imag);\n-      num imagAux = (this.imag * x.real + this.real * x.imag);\n+      num realAux = (real * x.real - imag * x.imag);\n+      num imagAux = (imag * x.real + real * x.imag);\n       return Complex(realAux, imagAux);\n     } else if (x is num) {\n-      return Complex(this.real * x, this.imag * x);\n+      return Complex(real * x, imag * x);\n     }\n     throw 'Not a number';\n   }\n \n   Complex operator /(var x) {\n     if (x is Complex) {\n-      num realAux = (this.real * x.real + this.imag * x.imag) /\n-          (x.real * x.real + x.imag * x.imag);\n-      num imagAux = (this.imag * x.real - this.real * x.imag) /\n-          (x.real * x.real + x.imag * x.imag);\n+      num realAux =\n+          (real * x.real + imag * x.imag) / (x.real * x.real + x.imag * x.imag);\n+      num imagAux =\n+          (imag * x.real - real * x.imag) / (x.real * x.real + x.imag * x.imag);\n       return Complex(realAux, imagAux);\n     } else if (x is num) {\n-      return Complex(this.real / x, this.imag / x);\n+      return Complex(real / x, imag / x);\n     }\n     throw 'Not a number';\n   }\n \n"
                },
                {
                    "date": 1641797298127,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-// ignore_for_file: unnecessary_getters_setters\n+// ignore_for_file: unnecessary_getters_setters, hash_and_equals\n \n import 'dart:math' as math;\n \n class Complex {\n@@ -19,15 +19,18 @@\n   num get imag => _imag;\n   set imag(num value) => _imag = value;\n   num get abs => math.sqrt(real * real + imag * imag);\n   num get angle => math.atan2(imag, real);\n+\n+  @override\n   bool operator ==(other) {\n     if (other is! Complex) {\n       return false;\n     }\n     return real == other.real && imag == other.imag;\n   }\n \n+  @override\n   String toString() {\n     if (_imag >= 0) {\n       return '$_real + ${_imag}i';\n     }\n"
                },
                {
                    "date": 1641799295165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -104,4 +104,88 @@\n         (c2.real * c2.real + c2.imag * c2.imag);\n     return Complex(real, imag);\n   }\n }\n+\n+// class Time:\n+//     \"\"\"Represents a date and time used for performing astronomy calculations.\n+//     ut : float\n+//     tt : float\n+//     \"\"\"\n+\n+//     def __init__(self, ut, tt=None):\n+//         self.ut = ut\n+//         if tt is None:\n+//             self.tt = _TerrestrialTime(ut)\n+//         else:\n+//             self.tt = tt\n+//         # self.etilt = None\n+\n+//     @staticmethod\n+//     def Parse(text):\n+//         \"\"\"Creates a #Time object from a string of the form 'yyyy-mm-ddThh:mm:ss.sssZ'\n+//         ----------\n+//         text : string ISO 8601\n+//             A string of the following formats:\n+//             `yyyy-mm-dd`\n+//             `yyyy-mm-ddThh:mmZ`\n+//             `yyyy-mm-ddThh:mm:ssZ`\n+//             `yyyy-mm-ddThh:mm:ss.sssZ`\n+//         Returns -> Time\n+//         \"\"\"\n+//         m = _TimeRegex.match(text)\n+//         if m is None:\n+//             raise DateTimeFormatError(text)\n+//         year = int(m.group(1))\n+//         month = int(m.group(2))\n+//         if not (1 <= month <= 12):\n+//             raise DateTimeFormatError(text)\n+//         day = int(m.group(3))\n+//         if not (1 <= day <= 31):\n+//             raise DateTimeFormatError(text)\n+//         hour = int(m.group(5) or '0')\n+//         if not (0 <= hour <= 23):\n+//             raise DateTimeFormatError(text)\n+//         minute = int(m.group(6) or '0')\n+//         if not (0 <= minute <= 59):\n+//             raise DateTimeFormatError(text)\n+//         second = float(m.group(8) or '0')\n+//         if not (0.0 <= second < 60.0):\n+//             raise DateTimeFormatError(text)\n+//         return Time.Make(year, month, day, hour, minute, second)\n+\n+//     @staticmethod\n+//     def Make(year, month, day, hour, minute, second):\n+//         \"\"\"Creates a #Time object from a UTC calendar date and time.\n+\n+//         Returns -> Time\n+//         \"\"\"\n+//         micro = round(math.fmod(second, 1.0) * 1000000)\n+//         second = math.floor(second - micro/1000000)\n+//         d = datetime.datetime(year, month, day, hour, minute, second, micro)\n+//         ut = (d - _EPOCH).total_seconds() / 86400\n+//         return Time(ut)\n+\n+//     @staticmethod\n+//     def Now():\n+//         \"\"\"Returns the computer's current date and time in the form of a #Time object.\n+\n+//         Returns -> Time\n+//         \"\"\"\n+//         ut = (datetime.datetime.utcnow() - _EPOCH).total_seconds() / 86400.0\n+//         return Time(ut)\n+\n+//     def AddDays(self, days):\n+//         \"\"\"Calculates the sum or difference of a #Time with a specified real-valued number of days.\n+\n+//         Returns -> Time\n+//         \"\"\"\n+//         return Time(self.ut + days)\n+\n+//     def Utc(self):\n+//         \"\"\"Returns the UTC date and time as a `datetime` object.\n+\n+//         Returns\n+//         -------\n+//         datetime\n+//         \"\"\"\n+//         return _EPOCH + datetime.timedelta(days=self.ut)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1641795618981,
            "name": "Commit-0",
            "content": "// ignore_for_file: unnecessary_getters_setters\n\nimport 'dart:math' as math;\n\nclass Complex {\n  num _real;\n  num _imag;\n\n  // 1- Here we define different ways to build a complex number:\n  // constructors:\n  Complex([this._real = 0, this._imag = 0]);\n  Complex.im(num imag) : this(0, imag);\n  Complex.re(num real) : this(real, 0);\n  // 2- The normal utility methods to get and set the real and\n  // imaginary part, to get the absolute value and the angle, to\n  //  compare two complex numbers:\n  num get real => _real;\n  set real(num value) => _real = value;\n  num get imag => _imag;\n  set imag(num value) => _imag = value;\n  num get abs => math.sqrt(real * real + imag * imag);\n  num get angle => math.atan2(imag, real);\n  bool operator ==(other) {\n    if (!(other is Complex)) {\n      return false;\n    }\n    return this.real == other.real && this.imag == other.imag;\n  }\n\n  String toString() {\n    if (_imag >= 0) {\n      return '${_real} + ${_imag}i';\n    }\n    return '${_real} - ${_imag.abs()}i';\n  }\n\n  // 3- operator overloading:\n  // The basic operations for adding, multiplying, subtraction and    //\n  //  division are defined as overloading of the operators +, *, - and /\n  Complex operator +(Complex x) {\n    return Complex(_real + x.real, _imag + x.imag);\n  }\n\n  Complex operator -(var x) {\n    if (x is Complex) {\n      return Complex(this.real - x.real, this.imag - x.imag);\n    } else if (x is num) {\n      _real -= x;\n      return this;\n    }\n    throw 'Not a number';\n  }\n\n  Complex operator *(var x) {\n    if (x is Complex) {\n      num realAux = (this.real * x.real - this.imag * x.imag);\n      num imagAux = (this.imag * x.real + this.real * x.imag);\n      return Complex(realAux, imagAux);\n    } else if (x is num) {\n      return Complex(this.real * x, this.imag * x);\n    }\n    throw 'Not a number';\n  }\n\n  Complex operator /(var x) {\n    if (x is Complex) {\n      num realAux = (this.real * x.real + this.imag * x.imag) /\n          (x.real * x.real + x.imag * x.imag);\n      num imagAux = (this.imag * x.real - this.real * x.imag) /\n          (x.real * x.real + x.imag * x.imag);\n      return Complex(realAux, imagAux);\n    } else if (x is num) {\n      return Complex(this.real / x, this.imag / x);\n    }\n    throw 'Not a number';\n  }\n\n  // 4- Here we define the same operations as methods:\n  static Complex add(Complex c1, Complex c2) {\n    num rr = c1.real + c2.real;\n    num ii = c1.imag + c2.imag;\n    return Complex(rr, ii);\n  }\n\n  static Complex subtract(Complex c1, Complex c2) {\n    num rr = c1.real - c2.real;\n    num ii = c1.imag - c2.imag;\n    return Complex(rr, ii);\n  }\n\n  static Complex multiply(Complex c1, Complex c2) {\n    num rr = c1.real * c2.real - c1.imag * c2.imag;\n    num ii = c1.real * c2.imag + c1.imag * c2.real;\n    return Complex(rr, ii);\n  }\n\n  static Complex divide(Complex c1, Complex c2) {\n    num real = (c1.real * c2.real + c1.imag * c2.imag) /\n        (c2.real * c2.real + c2.imag * c2.imag);\n    num imag = (c1.imag * c2.real - c1.real * c2.imag) /\n        (c2.real * c2.real + c2.imag * c2.imag);\n    return Complex(real, imag);\n  }\n}\n"
        }
    ]
}